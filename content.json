{"meta":{"title":"Jihoon's IT Development","subtitle":"Web Developer's Hobby Development Notes","description":"평소 개발이 취미인 개발자의 마구잡이 정리노트","author":"Park-JiHoon","url":"https://park-jihoon.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-11-25T15:25:47.000Z","updated":"2019-11-25T15:26:24.061Z","comments":true,"path":"tags/index.html","permalink":"https://park-jihoon.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-11-25T15:24:33.000Z","updated":"2019-11-25T15:26:14.287Z","comments":true,"path":"categories/index.html","permalink":"https://park-jihoon.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring boot의 ComponentScan 과 application.yml","slug":"Spring-boot의-ComponentScan-과-application-yml","date":"2020-01-03T14:21:14.000Z","updated":"2020-01-03T15:34:46.990Z","comments":true,"path":"2020/01/03/Spring-boot의-ComponentScan-과-application-yml/","link":"","permalink":"https://park-jihoon.github.io/2020/01/03/Spring-boot%EC%9D%98-ComponentScan-%EA%B3%BC-application-yml/","excerpt":"","text":"Spring Boot로 제작한 Application을 다른 Application에서 가져다 사용해보자.Spring Boot를 기반으로 제작한 Application을 다른 Application에서 가져다 사용하는 방법에 대해 알아보고, 문제가 될 수 있는 부분을 찾아본다. 1. 개요 Spring boot 를 기반으로 한 Demo1 제작 Demo1에서 application.yml에 값(value)을 입력 Demo1을 실행하여 application.yml의 값의 출력을 확인. Demo1 packaging Demo1의 jar 내부에 application.yml이 존재함을 확인. Demo1에 대한 의존성을 가지고있는 Demo2를 작성 Demo2에서 Demo1의 application.yml 값을 가져와지는지 확인. 2. Demo1Spring Boot 를 기반으로 한 Demo1을 제작합니다. 2.1. 폴더구성 실행을 위한 Demo1Application.java가 존재 application.yml의 값을 가져오기 위한 Demo1Tester.java가 위치 2.2. pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; lombok 이외에는 특별한거 하나 없는 intellij 기본 생성 Spring Boot Application이다. 2.3. application.ymltest.example.value 의 값으로 demo1을 세팅한다. 123test: example: value: demo1 2.4. Demo1Tester.java application.yml의 값을 가져오기 위한 ClassAutowired 테스트를 위해 @Component로 선언한다. 12345678910import lombok.Data;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Data@Componentpublic class Demo1Tester &#123; @Value(\"$&#123;test.example.value&#125;\") private String value;&#125; 2.5. Demo1Application.java Demo1Tester를 autowired 한 뒤 value 의 값을 가져와 log로 출력한다. 1234567891011121314151617181920212223242526import com.example.demo1.logic.Demo1Tester;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@Slf4j@SpringBootApplicationpublic class Demo1Application implements CommandLineRunner &#123; private final Demo1Tester tester; public Demo1Application(Demo1Tester tester) &#123; this.tester = tester; &#125; public static void main(String[] args) &#123; SpringApplication.run(Demo1Application.class, args); &#125; @Override public void run(String... args) throws Exception &#123; log.info(\"demo1 : tester.getValue() : &#123;&#125;\", tester.getValue()); &#125;&#125; 2.6. Demo1 실행결과123456789101112 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.2.RELEASE)2020-01-03 22:53:54.010 INFO 20040 --- [ main] com.example.demo1.Demo1Application : Starting Demo1Application on park-PC with PID 20040 (started by park in D:\\Dropbox\\프리랜서\\2020\\demo1)2020-01-03 22:53:54.014 INFO 20040 --- [ main] com.example.demo1.Demo1Application : No active profile set, falling back to default profiles: default2020-01-03 22:53:54.752 INFO 20040 --- [ main] com.example.demo1.Demo1Application : Started Demo1Application in 1.351 seconds (JVM running for 5.656)2020-01-03 22:53:54.754 INFO 20040 --- [ main] com.example.demo1.Demo1Application : tester.getValue() : demo1 demo1이 출력되는 것을 확인할 수 있다. 2.7. Demo1 packagingSpring Boot의 repackage를 스킵하도록 한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt; mvn clean install -DskipTests -Dspring-boot.repackage.skip=true[INFO] Scanning for projects...[INFO][INFO] -------------------------&lt; com.example:demo1 &gt;--------------------------[INFO] Building demo1 0.0.1-SNAPSHOT[INFO] --------------------------------[ jar ]---------------------------------[INFO][INFO] --- maven-clean-plugin:3.1.0:clean (default-clean) @ demo1 ---[INFO] Deleting D:\\Dropbox\\프리랜서\\2020\\demo1\\target[INFO][INFO] --- maven-resources-plugin:3.1.0:resources (default-resources) @ demo1 ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] Copying 1 resource[INFO] Copying 0 resource[INFO][INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ demo1 ---[INFO] Changes detected - recompiling the module![INFO] Compiling 2 source files to D:\\Dropbox\\프리랜서\\2020\\demo1\\target\\classes[INFO][INFO] --- maven-resources-plugin:3.1.0:testResources (default-testResources) @ demo1 ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] skip non existing resourceDirectory D:\\Dropbox\\프리랜서\\2020\\demo1\\src\\test\\resources[INFO][INFO] --- maven-compiler-plugin:3.8.1:testCompile (default-testCompile) @ demo1 ---[INFO] Changes detected - recompiling the module![INFO] Compiling 1 source file to D:\\Dropbox\\프리랜서\\2020\\demo1\\target\\test-classes[INFO][INFO] --- maven-surefire-plugin:2.22.2:test (default-test) @ demo1 ---[INFO] Tests are skipped.[INFO][INFO] --- maven-jar-plugin:3.1.2:jar (default-jar) @ demo1 ---[INFO] Building jar: D:\\Dropbox\\프리랜서\\2020\\demo1\\target\\demo1-0.0.1-SNAPSHOT.jar[INFO][INFO] --- spring-boot-maven-plugin:2.2.2.RELEASE:repackage (repackage) @ demo1 ---[INFO][INFO] --- maven-install-plugin:2.5.2:install (default-install) @ demo1 ---[INFO] Installing D:\\Dropbox\\프리랜서\\2020\\demo1\\target\\demo1-0.0.1-SNAPSHOT.jar to C:\\Users\\park\\.m2\\repository\\com\\example\\demo1\\0.0.1-SNAPSHOT\\demo1-0.0.1-SNAPSHOT.jar[INFO] Installing D:\\Dropbox\\프리랜서\\2020\\demo1\\pom.xml to C:\\Users\\park\\.m2\\repository\\com\\example\\demo1\\0.0.1-SNAPSHOT\\demo1-0.0.1-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 24.001 s[INFO] Finished at: 2020-01-03T22:55:24+09:00[INFO] ------------------------------------------------------------------------ 2.8. Demo1.jar application.yml 이 포함되었음을 확인할 수 있다. 3. Demo2Demo1에 의존성을 가지고 있는 Demo2를 생성한다. 3.1. 폴더구성 실행을 위한 Demo2Application.java가 존재 여러가지 케이스 테스트를 위한 application.yml 존재 3.2. pom.xml demo1 의 라이브러리를 dependency에 추가한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo2&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3.3. Demo2Application.java @ComponentScan 으로 demo1의 @Component를 탐색한다.Demo1Tester Class를 Autowired 한다.value 값을 출력한다. 12345678910111213141516171819202122232425262728import com.example.demo1.logic.Demo1Tester;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@Slf4j@SpringBootApplication@ComponentScan(basePackages = &#123;\"com.example.demo1\", \"com.example.demo2\"&#125;)public class Demo2Application implements CommandLineRunner &#123; private final Demo1Tester tester; public Demo2Application(Demo1Tester tester) &#123; this.tester = tester; &#125; public static void main(String[] args) &#123; SpringApplication.run(Demo2Application.class, args); &#125; @Override public void run(String... args) throws Exception &#123; log.info(\"demo2 : tester.getValue() : &#123;&#125;\", tester.getValue()); &#125;&#125; 4. 결과4.1. 시나리오1기본실행 Demo2 application.yml 삭제 (null) Demo2Application 실행 123452020-01-04 00:10:06.508 INFO 2968 --- [ main] com.example.demo2.Demo2Application : Starting Demo2Application on park-PC with PID 2968 (started by park in D:\\Dropbox\\프리랜서\\2020\\demo2)2020-01-04 00:10:06.514 INFO 2968 --- [ main] com.example.demo2.Demo2Application : No active profile set, falling back to default profiles: default2020-01-04 00:10:07.687 INFO 2968 --- [ main] com.example.demo2.Demo2Application : Started Demo2Application in 1.853 seconds (JVM running for 3.188)2020-01-04 00:10:07.693 INFO 2968 --- [ main] com.example.demo2.Demo2Application : demo2 : tester.getValue() : demo12020-01-04 00:10:07.695 INFO 2968 --- [ main] com.example.demo1.Demo1Application : demo1 : tester.getValue() : demo1 demo1과 demo2의 값이 demo1로 출력되는 것을 확인.demo1 : tester.getValue 은 demo2에 포함되는 코드가 아님에도 출력됐음을 확인. 4.2. 시나리오2 Demo2에 application.yml 추가 (empty) Demo2Application 실행 1234567892020-01-04 00:16:29.628 INFO 14512 --- [ main] com.example.demo2.Demo2Application : Starting Demo2Application on park-PC with PID 14512 (started by park in D:\\Dropbox\\프리랜서\\2020\\demo2)2020-01-04 00:16:29.636 INFO 14512 --- [ main] com.example.demo2.Demo2Application : No active profile set, falling back to default profiles: default2020-01-04 00:16:30.569 WARN 14512 --- [ main] s.c.a.AnnotationConfigApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'demo2Application': Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'demo1Tester': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'test.example.value' in value \"$&#123;test.example.value&#125;\"2020-01-04 00:16:30.583 INFO 14512 --- [ main] ConditionEvaluationReportLoggingListener : Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.2020-01-04 00:16:30.623 ERROR 14512 --- [ main] o.s.boot.SpringApplication : Application run failedorg.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'demo2Application': Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'demo1Tester': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'test.example.value' in value \"$&#123;test.example.value&#125;\" test.example.value 값이 존재하지 않아 Spring boot 실행 시 에러 발생 4.3. 시나리오3 Demo2에 application.yml에 값 추가 Demo2Application 실행 demo2/application.yml 123test: example: value: demo2 결과 123452020-01-04 00:18:22.742 INFO 19544 --- [ main] com.example.demo2.Demo2Application : Starting Demo2Application on park-PC with PID 19544 (started by park in D:\\Dropbox\\프리랜서\\2020\\demo2)2020-01-04 00:18:22.750 INFO 19544 --- [ main] com.example.demo2.Demo2Application : No active profile set, falling back to default profiles: default2020-01-04 00:18:23.970 INFO 19544 --- [ main] com.example.demo2.Demo2Application : Started Demo2Application in 1.969 seconds (JVM running for 3.285)2020-01-04 00:18:23.973 INFO 19544 --- [ main] com.example.demo2.Demo2Application : demo2 : tester.getValue() : demo22020-01-04 00:18:23.974 INFO 19544 --- [ main] com.example.demo1.Demo1Application : demo1 : tester.getValue() : demo2 demo1과 demo2의 값이 demo2로 출력되는 것을 확인.demo1 : tester.getValue 은 demo2에 포함되는 코드가 아님에도 출력됐음을 확인. 4.4. 결론 jar 내부 application.yml 은 @ComponentScan 시 값이 읽힐 수 있다. 다만 jar를 import 하는 application의 application.yml이 아예 존재하지 않아야 한다. 실행되는 application에 application.yml 설정파일이 존재한다면 jar내부의 application.yml은 무시된다. 실행되는 application의 application.yml 내부 값이 적용된다. 5. 추가 @ComponentScan 시 basePackages 설정에 대한 고민 위의 테스트에서 자꾸 demo2에 포함되지 않는 demo1의 코드가 실행되는 것을 알 수 있다. 이는 @ComponentScan의 basePackages에 com.example.demo1 로 설정되어있기 때문이다. (원하지 않는 Demo1Application이 실행될 수 있다는 이야기다.)따라서 다른 Application의 Component를 사용할 경우에는 최소한의 범위로 선언해서 사용할 수 있도록 해야한다. @ComponentScan(basePackages = {&quot;com.example.demo2&quot;, &quot;com.example.demo1.logic&quot;}) 12342020-01-04 00:23:49.949 INFO 10644 --- [ main] com.example.demo2.Demo2Application : Starting Demo2Application on park-PC with PID 10644 (started by park in D:\\Dropbox\\프리랜서\\2020\\demo2)2020-01-04 00:23:49.954 INFO 10644 --- [ main] com.example.demo2.Demo2Application : No active profile set, falling back to default profiles: default2020-01-04 00:23:51.010 INFO 10644 --- [ main] com.example.demo2.Demo2Application : Started Demo2Application in 1.862 seconds (JVM running for 3.134)2020-01-04 00:23:51.012 INFO 10644 --- [ main] com.example.demo2.Demo2Application : demo2 : tester.getValue() : demo2 com.example.demo1.logic 으로 선언했을 경우 Demo1Application 이 실행되지 않는것을 확인할 수 있다.","categories":[{"name":"Java","slug":"Java","permalink":"https://park-jihoon.github.io/categories/Java/"}],"tags":[{"name":"Java, Spring, Spring Boot","slug":"Java-Spring-Spring-Boot","permalink":"https://park-jihoon.github.io/tags/Java-Spring-Spring-Boot/"}]},{"title":"Spring Boot와 함께하는 Pivotal Gemfire 간단예제(2)","slug":"Spring-Boot와-함께하는-Pivotal-Gemfire-간단예제-2","date":"2019-12-15T15:22:01.000Z","updated":"2019-12-15T16:54:40.050Z","comments":true,"path":"2019/12/16/Spring-Boot와-함께하는-Pivotal-Gemfire-간단예제-2/","link":"","permalink":"https://park-jihoon.github.io/2019/12/16/Spring-Boot%EC%99%80-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-Pivotal-Gemfire-%EA%B0%84%EB%8B%A8%EC%98%88%EC%A0%9C-2/","excerpt":"","text":"목차 Pivotal Gemfire 다운로드 및 설치, 기본 설정 Spring Boot를 이용한 Gemfire 이용 지난시간에 이어서 간단한 테스트용 Region 생성과 Data 를 Region 안에 넣고 빼는 샘플 프로젝트를 제작해보자. 완성된 소스는 여기서 확인 가능하다. https://github.com/Park-jihoon/gemfire-demo Region 생성우선 gfsh 를 이용해 region 을 생성하자. region은 일반적인 DataBase로 치면 Table과 비슷한 역할을 하는 것으로 생성 시 많은 옵션을 줄 수 있다. 생성시 옵션은 대략 아래와 같다. 123456789101112131415161718192021222324create region --name=value [--type=value] [--template-region=value] [--groups=value(,value)*] [--if-not-exists(=value)?] [--key-constraint=value] [--value-constraint=value] [--enable-statistics=value] [--entry-idle-time-expiration=value] [--entry-idle-time-expiration-action=value] [--entry-time-to-live-expiration=value] [--entry-time-to-live-expiration-action=value] [--entry-idle-time-custom-expiry=value] [--entry-time-to-live-custom-expiry=value] [--region-idle-time-expiration=value] [--region-idle-time-expiration-action=value] [--region-time-to-live-expiration=value] [--region-time-to-live-expiration-action=value] [--disk-store=value] [--enable-synchronous-disk=value] [--enable-async-conflation=value] [--enable-subscription-conflation=value] [--cache-listener=value(,value)*] [--cache-loader=value] [--cache-writer=value] [--async-event-queue-id=value(,value)*] [--gateway-sender-id=value(,value)*] [--enable-concurrency-checks=value] [--enable-cloning=value] [--concurrency-level=value] [--colocated-with=value] [--local-max-memory=value] [--recovery-delay=value] [--redundant-copies=value] [--startup-recovery-delay=value] [--total-max-memory=value] [--total-num-buckets=value] [--compressor=value] [--off-heap(=value)] [--partition-resolver=value] [--eviction-entry-count=value] [--eviction-max-memory=value] [--eviction-action=value] [--eviction-object-sizer=value] 우선 region 생성 시 필수값인 name과 type만 살펴보자. name region을 해당 값의 이름으로 생성한다. DB의 tableName과 유사 type PARTITION, PARTITION_REDUNDANT, REPLICATE, LOCAL, etc. region type 에 따라 많은 타입이 존재하며 원하는 형태의 저장타입을 지정하면 된다. 이번 샘플에서는 아래의 두가지 region만 생성해본다. 123456789101112gfsh&gt;create region --name=testCache --type=REPLICATEMember | Status | Message------- | ------ | ----------------------------------------server1 | OK | Region \"/testCache\" created on \"server1\"Cluster configuration for group 'cluster' is updated.gfsh&gt;create region --name=customer --type=REPLICATEMember | Status | Message------- | ------ | ---------------------------------------server1 | OK | Region \"/customer\" created on \"server1\"Cluster configuration for group 'cluster' is updated. Spring Boot Sample 생성 환경 java 1.8 이상 Maven Spring boot 2.1.1.RELEASE Spring geode starter 1.2.1.RELEASE SpringFox Swagger 2.9.2 Directory 구조1234567891011121314151617181920Gemfire-demo|-- pom.xml`-- src `-- main `-- java `-- ko.co.pohinian.gemfiredemo |-- GemfireDemoApplication.java |-- configuration | |-- GemfireConfiguration.java | `-- SwaggerConfiguration.java |-- controller | |-- CustomerController.java | `-- TestCacheController.java |-- entity | |-- Customer.java | `-- TestCache.java |-- repository | `-- CustomerRepository.java `-- service `-- TestCacheService.java 파일 설명pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- gemfire --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.geode&lt;/groupId&gt; &lt;artifactId&gt;spring-geode-starter&lt;/artifactId&gt; &lt;version&gt;1.2.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- swagger2 --&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- test --&gt;&lt;/dependencies&gt; geode와 swagger2 관련 라이브러리는 버전을 명시해야 한다. GemfireDemoApplication.java실행을 위한 클래스를 생성한다. 123456@SpringBootApplicationpublic class GemfireDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GemfireDemoApplication.class, args); &#125;&#125; GemfireConfiguration.java gemfire를 사용하기 위한 설정을 모아두는 클래스 입니다. 12345678910111213141516171819202122232425262728@Configuration@EnableGemfireCachingpublic class GemfireConfiguration &#123; @Bean public ClientCache gemfireCache() &#123; ClientCacheFactory cacheFactory = new ClientCacheFactory(); cacheFactory.addPoolLocator(\"192.168.0.6\", 10334); return cacheFactory.create(); &#125; @Bean(\"testCache\") public ClientRegionFactoryBean&lt;String, TestCache&gt; testCache(@Autowired ClientCache clientCache) &#123; ClientRegionFactoryBean&lt;String, TestCache&gt; regionFactoryBean = new ClientRegionFactoryBean&lt;&gt;(); regionFactoryBean.setCache(clientCache); regionFactoryBean.setClose(false); regionFactoryBean.setShortcut(ClientRegionShortcut.PROXY); return regionFactoryBean; &#125; @Bean(\"customer\") public ClientRegionFactoryBean&lt;Long, Customer&gt; customer(@Autowired ClientCache clientCache) &#123; ClientRegionFactoryBean&lt;Long, Customer&gt; regionFactoryBean = new ClientRegionFactoryBean&lt;&gt;(); regionFactoryBean.setCache(clientCache); regionFactoryBean.setClose(false); regionFactoryBean.setShortcut(ClientRegionShortcut.PROXY); return regionFactoryBean; &#125;&#125; @EnableGemfireCaching 으로 gemfire cache를 사용할 것임을 명시한다. gemfireCache()에서 연결하기위한 Gemfire 서버의 정보를 설정한다. 192.168.0.6은 이전 글에서 시작한 locator 정보의 ip이다. 기본 local 접속이기때문에 별도의 username 과 password 는 설정하지 않는다. 하지만 별도의 서버를 구성할 경우에는 서버의 gemfire username과 password를 추가해야 한다. customer와 testCache는 동명의 region에 대한 정보를 입력한다. ClientRegionShortcut.PROXY는 애플리케이션에서 저장되는 정보를 어떠한 방식으로 처리할지를 지정하는 것으로 기본값음 LOCAL이다. LOCAL인 경우 값을 애플리케이션에서만 가지고 있게 되며 서버로 전송하지 않는다. 별도의 서버를 두고 데이터를 공유할 경우에는 PROXY로 지정해줘야 한다. Customer 저장 및 로드Customer 는 org.springframework.data.repository.CrudRepository를 사용하여 데이터를 저장 및 삭제하는 예제다. Customer.javaregion 정보를 명시해주는 클래스다. 123456789101112131415@Data@ToString@Region(\"customer\")@NoArgsConstructor@RequiredArgsConstructor(staticName = \"newCustomer\")public class Customer implements Serializable &#123; @Id @NonNull @Getter private Long id; @NonNull @Getter private String name;&#125; Serializable은 java 끼리만 gemfire의 데이터를 공유할 경우에 사용하면 간편하다.다만 다른 언어들과 데이터를 공유할 경우에는 DataSerializable 등을 구현하여줘야 한다. CustomerRepository.java 12public interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt; &#123;&#125; Customer의 ID 타입인 Long 을 명시해준다.gemfire 이외의 기술을 선택할 경우를 대비해 유연하도록 CrudRepository를 구현해준다.findByName 등 jpa 에서 사용하던 형태의 메서드를 선언해 사용 가능하다. CustomerController.java Customer 의 정보를 저장하기 위한 Rest Controller 이다. 123456789101112131415161718192021@RestController@RequestMapping(\"customer\")public class CustomerController &#123; private final CustomerRepository customerRepository; public CustomerController(CustomerRepository customerRepository) &#123; this.customerRepository = customerRepository; &#125; @PostMapping(\"&#123;key&#125;\") public Customer put(@PathVariable(\"key\") Long key, @RequestBody String name) &#123; Customer customer = Customer.newCustomer(key, name); return customerRepository.save(customer); &#125; @GetMapping(\"&#123;key&#125;\") public Customer get(@PathVariable(\"key\") Long key) &#123; return customerRepository.findById(key).orElse(new Customer()); &#125;&#125; @RestController는 RestApi로 사용하기 위해 선언한다.CustomerRepository의 Save 및 findById를 사용한다. save와 findById는 자동으로 생성된다.Customer.newCustomer(key, name) 입력된 값으로 저장을 위한 신규 객체를 생성한다.orElse(new Customer()) 값이 존재하지 않을 경우 빈 객체를 리턴한다. Customer 테스트 저장테스트 12345&gt; curl -X POST \"http://localhost:8080/customer/1\" -H \"accept: */*\" -H \"Content-Type: application/json\" -d \"테스트\"&#123; \"id\": 1, \"name\": \"테스트\"&#125; 저장한 값을 리턴한다. 12345&gt; curl -X GET \"http://localhost:8080/customer/1\" -H \"accept: */*\"&#123; \"id\": 1, \"name\": \"테스트\"&#125; Region 정보 확인 123456789101112gfsh&gt;describe region --name=customerName : customerData Policy : replicateHosting Members : server1Non-Default Attributes Shared By Hosting Members Type | Name | Value------ | ----------- | ---------------Region | data-policy | REPLICATE | size | 1 | scope | distributed-ack TestCache 저장 및 로드TestCache는 org.springframework.cache를 이용해 최소한의 설정값 만으로 Gemfire를 사용하기 위한 예제이다. TestCache.java TestCache는 일반적인 java entity 파일이다. 별도의 gemfire를 위한 설정은 존재하지 않는다. 1234567@Data@EqualsAndHashCode@ToStringpublic class TestCache implements Serializable &#123; private String name; private String addr;&#125; TestCacheService.java 12345678910111213@Servicepublic class TestCacheService &#123; @CachePut(cacheNames = \"testCache\", key = \"#key\") public TestCache put(String key, TestCache testCache) &#123; return testCache; &#125; @Cacheable(cacheNames = \"testCache\", key = \"#key\") public TestCache get(String key) &#123; return null; &#125;&#125; @CachePut, @Cacheable 등 Spring Cache 를 이용해 Gemfire 의 Region에 데이터를 저장 및 로드 가능하다.반드시 @Service 레벨이어야 한다. 또한, proxy 패턴을 이용하는 것이므로 같은 Class 내부에서 호출하는 부분은 캐싱되지않는다.cacheNames = &quot;testCache&quot; 으로 region의 이름을 명시한다.key = &quot;#key&quot;와 같이 매개변수명을 조합해 key를 지정할 수 있다. TestCacheController.java 123456789101112131415161718192021@RestController@RequestMapping(\"cache\")public class TestCacheController &#123; private final TestCacheService testCacheService; public TestCacheController(TestCacheService testCacheService) &#123; this.testCacheService = testCacheService; &#125; @PostMapping(\"&#123;key&#125;\") public TestCache put(@PathVariable(\"key\") String key, @RequestBody TestCache value) &#123; return testCacheService.put(key, value); &#125; @GetMapping(\"&#123;key&#125;\") public TestCache get(@PathVariable(\"key\") String key) &#123; return testCacheService.get(key); &#125;&#125; TestCacheService를 이용해 데이터를 저장 및 로드 한다. TestCache 테스트 저장 12345&gt; curl -X POST \"http://localhost:8080/cache/1\" -H \"accept: */*\" -H \"Content-Type: application/json\" -d \"&#123; \\\"addr\\\": \\\"테스트주소\\\", \\\"name\\\": \\\"테스트이름\\\"&#125;\"&#123; \"name\": \"테스트이름\", \"addr\": \"테스트주소\"&#125; 로드 12345curl -X GET \"http://localhost:8080/cache/1\" -H \"accept: */*\"&#123; \"name\": \"테스트이름\", \"addr\": \"테스트주소\"&#125; Region 정보 확인 123456789101112gfsh&gt;describe region --name=testCacheName : testCacheData Policy : replicateHosting Members : server1Non-Default Attributes Shared By Hosting Members Type | Name | Value------ | ----------- | ---------------Region | data-policy | REPLICATE | size | 1 | scope | distributed-ack 저장된 것을 확인할 수 있다. 참고 gfsh(gemfire.docs.pivotal.io) Region Types(gemfire.docs.pivotal.io)","categories":[{"name":"Java","slug":"Java","permalink":"https://park-jihoon.github.io/categories/Java/"}],"tags":[{"name":"Java, Spring, Spring Boot, Gemfire","slug":"Java-Spring-Spring-Boot-Gemfire","permalink":"https://park-jihoon.github.io/tags/Java-Spring-Spring-Boot-Gemfire/"}]},{"title":"Spring Boot와 함께하는 Pivotal Gemfire 간단예제(1)","slug":"Spring-Boot와-함께하는-Pivotal-Gemfire-간단예제(1)","date":"2019-12-10T14:21:25.000Z","updated":"2019-12-15T15:21:08.460Z","comments":true,"path":"2019/12/10/Spring-Boot와-함께하는-Pivotal-Gemfire-간단예제(1)/","link":"","permalink":"https://park-jihoon.github.io/2019/12/10/Spring-Boot%EC%99%80-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-Pivotal-Gemfire-%EA%B0%84%EB%8B%A8%EC%98%88%EC%A0%9C(1)/","excerpt":"","text":"목차 Pivotal Gemfire 다운로드 및 설치, 기본 설정 Spring Boot를 이용한 Gemfire 이용 갑작스럽지만 애플리케이션의 Cache를 담당해주던 Redis를 Pivotal Gemfire 로 변경하기로 했다. 이런 결정에는 몇가지 이유가 존재했는데. 현재 프로젝트에서 사용하는 클라우드 환경은 PCF(Pivotal Cloud Foundry)로 Gemfire를 기반으로 하는 PCC(Pivotal Cloud Cache)를 간편하게 서비스로 등록 및 사용할 수 있다. 여건상 Redis 를 사용할 경우 PCF 환경의 외부에 Redis 서버가 존재할 수 밖에 없었다. 이왕 Pivotal 제품인 PCF 를 쓰는거 끝까지 Pivotal 제품을 사용하기로 맘 먹은 부분도 크다. (기술 지원의 일원화?!) 1.1. Pivotal Gemfire 란Pivotal GemFire는 글로벌 레벨로 데이터 동기화가 가능한 인 메모리 데이터 그리드(In-Memory Data Grid)다. 오픈소스 버전으로는 Apache Geode가 존재한다. 주요기능을 요약하자면 다음과 같다. 읽기-쓰기 처리량이 높음.(High Read-and-Write Throughput) 대기 시간이 낮으면서 예측 가능.(Low and Predictable Latency) 높은 확장성.(High Scalability) 지속적인 가용성.(Continuous Availability) 안정적인 이벤트 알림.(Reliable Event Notifications) 데이터 저장소 상의 병렬화 된 애플리케이션 동작.(Parallelized Application Behavior on Data Stores) 비공유 데이터 지속성.(Shared-Nothing Disk Persistence) 소유 비용 절감(Reduced Cost of Ownership) 클라이언트 / 서버를위한 단일 홉 기능(Single-Hop Capability for Client/Server) 클라이언트 / 서버 보안(Client/Server Security) 멀티 사이트 데이터 배포(Multisite Data Distribution) 연속 쿼리(Continuous Querying) 이기종 데이터 공유(Heterogeneous Data Sharing) 참고 : Gemfire Main Features 단순 Cache로 쓰기에는 넘쳐 흐르는 기능이 아닐 수 없다. 1.2. Gemfire 다운로드Windows 운영체제 기반으로 설명한다.나머지 운영체제의 설치는 여기서 확인 가능하다. Pivotal 홈페이지에서 Gemfire 최신버전 다운로드 Gemfire 9.9.0 다운로드 원하는 폴더로 압축파일을 해제 bin 폴더를 path 에 추가. 1.3. GFSH 실행 및 로컬 실행 명령 프롬프트 창 열기 gfsh(Gemfire Shell) 실행 123456789101112Microsoft Windows [Version 10.0.18362.476](c) 2019 Microsoft Corporation. All rights reserved.C:\\Users\\park&gt;gfsh _________________________ __ / _____/ ______/ ______/ /____/ / / / __/ /___ /_____ / _____ / / /__/ / ____/ _____/ / / / //______/_/ /______/_/ /_/ 9.9.0Monitor and Manage Pivotal GemFiregfsh&gt; 간단하다. 실행을 위해서는 locator 와 server 를 기동해야 한다. locator 기동 gfsh&gt;start locator --name=locator1 123456789101112131415gfsh&gt;start locator --name=locator1Starting a Geode Locator in C:\\Users\\park\\locator1.....Locator in C:\\Users\\park\\locator1 on park-PC[10334] as locator1 is currently online.Process ID: 19028Uptime: 1 minute 1 secondGeode Version: 9.9.0Java Version: 1.8.0_77Log File: C:\\Users\\park\\locator1\\locator1.logJVM Arguments: -Dgemfire.enable-cluster-configuration=true -Dgemfire.load-cluster-configuration-from-dir=false -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806Class-Path: D:\\workspace\\pivotal-gemfire-9.9.0\\lib\\geode-core-9.9.0.jar;D:\\workspace\\pivotal-gemfire-9.9.0\\lib\\geode-dependencies.jarSuccessfully connected to: JMX Manager [host=park-PC, port=1099]Cluster configuration service is up and running. server 기동 gfsh&gt;start server --name=server1 1234567891011gfsh&gt;start server --name=server1Starting a Geode Server in C:\\Users\\park\\server1.....Server in C:\\Users\\park\\server1 on park-PC[40404] as server1 is currently online.Process ID: 10964Uptime: 1 minute 1 secondGeode Version: 9.9.0Java Version: 1.8.0_77Log File: C:\\Users\\park\\server1\\server1.logJVM Arguments: -Dgemfire.default.locators=192.168.0.6[10334] -Dgemfire.start-dev-rest-api=false -Dgemfire.use-cluster-configuration=true -XX:OnOutOfMemoryError=taskkill /F /PID %p -Dgemfire.launcher.registerSignalHandlers=true -Djava.awt.headless=true -Dsun.rmi.dgc.server.gcInterval=9223372036854775806Class-Path: D:\\workspace\\pivotal-gemfire-9.9.0\\lib\\geode-core-9.9.0.jar;D:\\workspace\\pivotal-gemfire-9.9.0\\lib\\geode-dependencies.jar locator와 server 기동 확인 gfsh&gt;list members 1234567gfsh&gt;list membersMember Count : 2 Name | Id-------- | ---------------------------------------------------------------locator1 | 192.168.0.6(locator1:19028:locator)&lt;ec&gt;&lt;v0&gt;:41000 [Coordinator]server1 | 192.168.0.6(server1:10964)&lt;v1&gt;:41001 여기까지가 Gemfire 기동 준비다. 다음에는 Gemifre 의 Table 이라고 할 수 있는 region 생성과 간단히 Spring Boot 를 이용한 Spring Data Gemfire Cache 샘플 프로젝트를 만들어 보겠다.","categories":[{"name":"Java","slug":"Java","permalink":"https://park-jihoon.github.io/categories/Java/"}],"tags":[{"name":"Java, Spring, Spring Boot, Gemfire","slug":"Java-Spring-Spring-Boot-Gemfire","permalink":"https://park-jihoon.github.io/tags/Java-Spring-Spring-Boot-Gemfire/"}]},{"title":"HTML 로 1px 미만 선 인쇄하기","slug":"HTML-로-1px-미만-선-인쇄하기","date":"2019-12-09T14:47:38.000Z","updated":"2019-12-10T14:23:04.627Z","comments":true,"path":"2019/12/09/HTML-로-1px-미만-선-인쇄하기/","link":"","permalink":"https://park-jihoon.github.io/2019/12/09/HTML-%EB%A1%9C-1px-%EB%AF%B8%EB%A7%8C-%EC%84%A0-%EC%9D%B8%EC%87%84%ED%95%98%EA%B8%B0/","excerpt":"","text":"픽셀과 포인트브라우저에서 선을 표현하는 단위는 대부분 px 입니다. 픽셀이죠. 이는 상대적인 값입니다. 디지털 이미지를 화면에 재현하기 위한 단위로, 이미지를 이루는 가장 작은 단위를 뜻합니다. 픽셀을 많이 표현할 수 있다. = 해상도가 높다. 로 표현할 수 있으며, 이는 더 정교하게 이미지를 표현할 수 있다는 것을 의미합니다. 즉, 픽셀은 모니터의 해상도, 크기 및 OS(windows, MAC OS) 등에 따라 바뀔 수 있는 상대적인 값임을 알 수 있습니다. 하지만 인쇄의 영역에서 사용하는 단위인 pt는 다릅니다. 포인트라고 불리는 값은 절대적인 값입니다. 1인치를 72로 나눈 값으로 1pt = 1/72 inch = 약 0.3527 입니다. 오늘은 px로 표현한 웹 문서를 가지고 인쇄물로 출력하면서 발생한 이슈에 대해 이야기해보겠습니다. 굵은 1px1px 굵기의 선으로 구성된 통계표를 출력해 받아본 고객에게서 다음과 같은 반응이 나왔습니다. 프린트 해서 봤더니 선이 너무 굵어요. 좀 더 얇게 해주세요. 당초 계획은 통계표를 웹에서 구성한 뒤 PDF파일로 제공하고, PDF파일을 고객이 프린터로 출력해서 제본하는 것이었습니다. 하지만 고객이 받아본 통계표 PDF는 고객 기준으로는 매우 굵은 선을 가지고 있었습니다. 다시 말하지만 통계표(table)의 선 굵기(border)는 1px 이었습니다. 간단한 html로 표현해보자. 123456789101112131415161718&lt;!doctype html&gt;&lt;html&gt;&lt;style&gt;table.one &#123; border: solid black 1px; border-collapse: collapse;&#125;td.one &#123; border: solid black 1px;&#125;&lt;/style&gt;&lt;table class=\"one\"&gt; &lt;tr&gt; &lt;td class=\"one\"&gt;가나다라&lt;/td&gt; &lt;td class=\"one\"&gt;1234&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/html&gt; 검은색 1px 굵기의 선을 가진 테이블 입니다. 아래와 같이 표현됩니다. 얼핏 보기에는 얇아보이는 선입니다. 하지만 A4용지 혹은 B4용지로 출력해서 살펴본 고객은 한글(HWP)로 제작된 표에 비해 선이 굵어보인다고 했습니다. 실제로 양쪽 출력물을 비교해봐도 HTML 기반 출력물이 더 굵었습니다. 이때까지는 단순하게 생각했습니다. 0.5px 정도 주면 해결되겠네. 1234567891011121314151617181920212223242526272829&lt;style&gt;table.one &#123; border: solid black 1px; border-collapse: collapse;&#125;td.one &#123; border: solid black 1px;&#125;table.two &#123; border: solid black 0.5px; border-collapse: collapse;&#125;td.two &#123; border: solid black 0.5px;&#125;&lt;/style&gt;&lt;table class=\"one\"&gt; &lt;tr&gt; &lt;td class=\"one\"&gt;가나다라&lt;/td&gt; &lt;td class=\"one\"&gt;1234&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;hr/&gt;&lt;table class=\"two\"&gt; &lt;tr&gt; &lt;td class=\"two\"&gt;가나다라&lt;/td&gt; &lt;td class=\"two\"&gt;1234&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; two 라는 클래스의 table을 하나 더 생성한 뒤 선의 굵기를 0.5px 로 줬습니다. 단순히 1px의 절반 굵기의 선이 생성되기를 기대했습니다. 하지만 어림도 없지. 1px 이하의 굵기는 화면에서 표현할 수 없는게 당연했습니다. (표현의 최소 단위니까…) 물론 일반적인 해상도로 봤을 때는 동일해보이지만 확대를 하게되면 두 테이블은 확연히 다른 선 굵기를 가지고 있음을 알 수 있습니다. 화면은 확대가 가능하지만 출력물은 확대를 할 수 없습니다. 슬슬 출력물에 대한 부담감이 몰려왔습니다. 하지만 막연히 PDF 또는 프린트 드라이버가 알아서 해주실거야! 라는 생각도 드는 순간 입니다. 아래는 위의 html을 PDF로 출력한 결과 입니다. (잘 안보일까봐 200% 확대 출력 했습니다.) [PDF로 확인해보자!] 하느님 맙소사. 출력된 pdf에는 0.5px 과 1px 이 모두 1px 로 표현되는 것을 확인할 수 있었습니다. 이리저리 찾아본 결과 chrome 에서 print pdf로 pdf 를 생성할 경우 1px 미만의 선은 제대로 표현이 되지 않는다는 정보가 있었습니다. 이는 현재 기준으로도 수정될 가능성이 없어보이는 이슈로 headless chrome라이브러리인 puppeteer를 이용한 pdf export 시에도 마찬가지로 발생하고 있었습니다. 해결방안 테스트1 - 투명도검색 결과 1px 미만의 선을 표현하기 위한 많은 개발자들의 노력과 답변들이 존재했습니다. 다만, 인쇄를 해야겠다라는 개발자는 많지 않았습니다. 우선 화면에서 표현이 된다는 CSS 트릭 부터 테스트해봤습니다. 바로 투명도를 이용한 방식 입니다. 123456789101112131415161718&lt;!doctype html&gt;&lt;html&gt;&lt;style&gt;.container &#123; border-style: solid; border-width: 1px; margin-bottom: 10px;&#125;.border-100 &#123;border-color: rgba(0,0,255,1);&#125;.border-75 &#123;border-color: rgba(0,0,255,0.75);&#125;.border-50 &#123;border-color: rgba(0,0,255,0.5);&#125;.border-25 &#123;border-color: rgba(0,0,255,0.25);&#125;&lt;/style&gt;&lt;div class=\"container border-100\"&gt;1px&lt;/div&gt;&lt;div class=\"container border-75\"&gt;0.75px&lt;/div&gt;&lt;div class=\"container border-50\"&gt;0.5px&lt;/div&gt;&lt;div class=\"container border-25\"&gt;0.25px&lt;/div&gt;&lt;/html&gt; 1px 미만의 선은 표현하기 어렵기 때문에 선의 투명도를 조절하여 얇게 보이도록 하는 트릭 입니다. 화면에서의 결과는 아래와 같습니다. 모니터 너머로 보이는 선은 정말 얇아보입니다. 0.25px 정도는 억지스러워보이지만 0.5px 정도까지는 눈감고 넘어가줄만 합니다. 이제 인쇄만 이쁘게 되면 됩니다. [PDF로 확인해보자!] PDF로 출력된 선은 뚜꺼워 보였으며, 얇아지지도 않았습니다. 투명해져가는 선은 단순히 프린터의 잉크가 떨어진 것 처럼 보일 뿐이었습니다. 화면과 출력물은 다르다 라는 교훈만 얻게 되었습니다. 해결방안 테스트2 - background-image 속성CSS에는 border-image 속성이 존재합니다. 이는 image 파일을 border 에 줄 수 있는 것으로, HTML BOX를 디자인하기 좋아지는 속성 입니다. 구현은 간단하지 않은 관계로(현재 기억이 자세히 나지 않….) 히스토리만 적어보겠습니다. 디자이너에게 0.5px 선 이미지를 요청해 받았습니다. (포토샵은 대단합니다.) border-image 속성으로 표현합니다. 필요에 따라 회전 시키며 사용합니다. 결과적으로는 PDF 상에 0.5px 를 표현하는데 성공했습니다. 이미지는 벡터로 랜더링 되는 선이 아니라 이미지 그 자체이기 때문에 문제가 없어 보였습니다. 다만 문제가 있었습니다. 구현 방식이 너무 복잡해, 수시로 편집 및 병합이 될 수 있는 통계표 테이블에 적용해주기는 어려웠던 것입니다. 때문에 절반의 성공으로 다음을 기약할 수 밖에 없었습니다. 해결방안 테스트 3마지막 방법은 @media print를 이용해 print시 적용되는 css를 별도로 제작하는 것 입니다.이 방법에는 약간의 트릭이 있습니다. PDF print시 1px 미만이 표현되지 않는 문제 회피 필요. @media print CSS에서 1px 미만의 숫자가 존재하지 않도록 기존의 CSS 수치에 일정 수치를 곱해준다. 예&gt; 0.5px 이 가장 얇은 선일 경우 = 모든 수치를 2배 1px =&gt; 2px, 0.5px =&gt; 1px 마지막으로 body 부분에 0.5배 축소 설정을 추가 아래는 예 입니다. @media screen 1234567891011@media screen &#123; .container &#123; border-style: solid; border-width: 1px; margin-bottom: 10px; font-size: 14px; &#125; .border-100 &#123;border-width:1px&#125; .border-75 &#123;border-width:0.75px&#125; .border-50 &#123;border-width:0.5px&#125; .border-25 &#123;border-width:0.25px&#125; @media print 123456789101112131415@media print &#123; body &#123; transform: scale(.25); &#125; .container &#123; border-style: solid; border-width: 4px; margin-bottom: 40px; font-size: 56px; &#125; .border-100 &#123;border-width:4px&#125; .border-75 &#123;border-width:3.05px&#125; .border-50 &#123;border-width:2.5px&#125; .border-25 &#123;border-width:1px&#125;&#125; 문제없이 pdf 에서 원하는 굵기가 출력되는 것을 확인할 수 있었습니다. 결론프로젝트에서는 세가지 방법 중 가장 만족도가 높았던 3안을 선택하여 제작했습니다. WEB의 화면을 PDF로 출력한다는 일반적이지 않은 작업이었지만 원하는 결과에 가까운 출력물을 얻을 수 있어 다행이었습니다. 모든 CSS의 굵기를 계산해서 만들어야 한다는 점이 어렵게 느껴질 수 있겠지만, SASS 등과 같이 CSS를 일괄 빌드할 수 있는 툴을 사용한다면 print CSS를 빠르게 생성할 수 있으니 충분히 쓸만해 보입니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"https://park-jihoon.github.io/categories/Etc/"}],"tags":[{"name":"html","slug":"html","permalink":"https://park-jihoon.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://park-jihoon.github.io/tags/css/"}]},{"title":"Maven Dependency Scope의 종류","slug":"Maven-Dependency-Scope의-종류","date":"2019-11-27T15:33:48.000Z","updated":"2019-11-27T16:27:07.622Z","comments":true,"path":"2019/11/28/Maven-Dependency-Scope의-종류/","link":"","permalink":"https://park-jihoon.github.io/2019/11/28/Maven-Dependency-Scope%EC%9D%98-%EC%A2%85%EB%A5%98/","excerpt":"","text":"Dependency(의존성) 범위는 의존성의 transitive(전이)를 제한하고 다양한 빌드 작업에 사용되는 classpath에 영향을주기 위해 사용됩니다. Maven에서 의존성을 선언하는 방법은 대략적으로 아래와 같습니다. pom.xml 123456789101112&lt;project&gt; ... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;artifactId&gt;foo-bar&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;$&#123;scope&#125;&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ...&lt;/project&gt; 의존성에는 총 6가지의 scope가 존재합니다. compile 지정되지 않은 경우 사용되는 기본 scope 입니다. Compile로 선언된 dependencies는 프로젝트의 모든 classpath에서 사용할 수 있습니다. 또한 이러한 의존성은 종속 프로젝트로 전파됩니다. provided Compile과 비슷하지만 프로잭트 실행 시 라이브러리에 대한 의존성을 JDK 또는 container(ex.tomcat) 가 제공 할 것으로 예상함을 나타냅니다. 예를 들자면, Java Enterprise Edition 용 web Applicaton 을 빌드할 경우 web container 가 Servlet API 및 관련 Java EE API 에 대한 class 및 의존성을 제공하므로 provided로 설정합니다. 이 scope는 compile 및 test 시에만 사용되며 전이되지 않습니다. runtime compile에는 필요하지 않지만 실행 시 필요할 경우 사용합니다. runtime이 선언된 의존성은 runtime 과 test classpath 에 존재하지만 compile classpath 에는 존재하지 않습니다. test application 을 정상적으로 사용하는데는 필요하지 않지만 test 컴파일 또는 실행 시 필요함을 의미합니다. 이 scope는 전이되지 않습니다. system 이 scope는 명시 적으로 포함하는 JAR 을 제공해야한다는 점을 제외하고, provided와 유사합니다. artifact 는 항상 사용 가능하며 repository 에서는 검색되지 않습니다. import &lt;dependencyManagement&gt; 영역 내부 pom 타입의 의존성 에만 지원됩니다. 다른 프로젝트에서 관리되는 의존성 목록을 가져오기 위해서 사용합니다. import scope로 선언된 POM 의 의존성 목록은 실제로 의존성의 전이에 참여하지 않습니다. 참고 : http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope","categories":[{"name":"Java","slug":"Java","permalink":"https://park-jihoon.github.io/categories/Java/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://park-jihoon.github.io/tags/maven/"},{"name":"java","slug":"java","permalink":"https://park-jihoon.github.io/tags/java/"}]},{"title":"Maven으로 Spring boot 배포 시 repackge 방지","slug":"Maven으로-Spring-boot-배포-시-repackge-방지","date":"2019-11-26T16:21:12.000Z","updated":"2019-11-27T16:32:06.875Z","comments":true,"path":"2019/11/27/Maven으로-Spring-boot-배포-시-repackge-방지/","link":"","permalink":"https://park-jihoon.github.io/2019/11/27/Maven%EC%9C%BC%EB%A1%9C-Spring-boot-%EB%B0%B0%ED%8F%AC-%EC%8B%9C-repackge-%EB%B0%A9%EC%A7%80/","excerpt":"","text":"개요다른 프로젝트에서 Spring Boot Application 의 jar를 참조하여 사용하기 위해서는 Maven Deploy시 실행 가능한 jar가 아닌 Original jar 가 배포 되어야 함. Spring Boot Maven PluginMaven을 이용하여 Spring Boot Application을 빌드 할 경우 특별한 경우가 아니라면 Spring Boot Maven Plugin을 활용하게 될겁니다. Spring Boot Maven Plugin은 아래와 같은 몇가지 기능을 제공합니다. repackage : 자동 실행 가능한 jar 또는 war 파일을 만듭니다. run : Spring Boot Application이 매개변수를 전달하는 여러가지 옵션과 함께 실행됩니다. start and stop : Application 이 시작되기 전 integration-test 단계를 수행할 수 있습니다. build-info : Actuator가 사용할 수있는 빌드 정보를 생성합니다. 이 중 이번에 살펴볼 부분은 repackage 입니다. Repackaging an application간단한 예제 입니다. 1234567891011121314151617181920&lt;build&gt; ... &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; ... &lt;/plugins&gt; ...&lt;/build&gt; repackage는 Maven 수명주기의 package 단계에서 빌드 된 jar 또는 war를 다시 패키지(repackage)합니다. Plugin은 Application을 repackage 하면서 프로젝트의 dependency를 참고하여 필요한(종속된) 라이브러리를 포함시킵니다. 때문에 용량이 매우 크죠. repackage 되기 전 jar 또는 war 는 .original 확장자가 추가로 붙어 보존 됩니다. 실행 가능한 jar는 빌드 및 테스트시에 매우 유용합니다. 독립 실행이 가능하기 때문에 배포 역시 편리해지지요. 하지만 Application의 코드가 다른 프로젝트에서 사용되어야 한다면 어떨까요. 이런경우 다른 팀원과 공유해야 할 경우에 jar.original 파일을 건네주는 것은 의미가 없습니다.(다른 팀원도 Maven을 사용하고 있을테니까요.) 우리는 jar.original 파일을 사내 Maven Repository에 배포해야 합니다. Deploy Maven Repository여기서 사내 Maven Repository에 접근하기위한 Maven의 settings.xml 파일 설정 등의 설명은 하지 않겠습니다. 모든 설정이 잘 되어있다고 가정했을 경우 일반적인 배포 명령어는 아래와 같습니다. 1mvn clean deploy 이제 pom.xml 에 dependency 설정만 해주면 되겠군요! 하지만 다른 팀원의 pom.xml에 정상적으로 dependency 설정을 완료하더라도 Class를 찾을 수 없다는 에러가 발생합니다. 이유는 간단합니다. original jar가 아닌 실행가능한 jar가 배포되었기 때문이죠. 실행가능한 jar(혹은 war)는 아래의 디렉토리 구조에서 알 수 있듯 jar.original과 다른 구조를 가지게 되며, dependency에 선언되더라도 Class를 찾을 수 없습니다. 또한, 실행이 되더라도 배포하기에는 너무나 거대한 용량을 가지게 되죠. 다른 팀원에게 제공되어야 하는 jar 는 실행이 가능하도록 repackage 되기 전의 결과물인 original jar 입니다. Spring Boot Maven Plugin:repackage모든일의 원흉(?)이라고 할 수 있는 Spring Boot Maven Plugin의 repackage 문서를 살펴봅시다. Optional Parameters에 흥미로운 파라미터가 보입니다. 바로 skip이죠. skip Skip the execution. Type: boolean Since: 1.2.0 Required: No User Property: spring-boot.repackage.skip Default: false 실행을 Skip 할 수 있다는 군요. 해결책을 찾은 것 같습니다. 결론Maven Deploy 시 Original jar 를 배포하기 위한 명령어는 다음과 같습니다. 1mvn clean deploy -Dspring-boot.repackage.skip=true 참고 : https://docs.spring.io/spring-boot/docs/current/maven-plugin/repackage-mojo.html","categories":[{"name":"Java","slug":"Java","permalink":"https://park-jihoon.github.io/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://park-jihoon.github.io/tags/Spring-Boot/"},{"name":"Maven","slug":"Maven","permalink":"https://park-jihoon.github.io/tags/Maven/"}]},{"title":"Jenkins Blue Ocean 으로 배포하기","slug":"Jenkins-Blue-Ocean-으로-배포하기","date":"2018-08-29T00:45:22.000Z","updated":"2019-11-25T14:50:11.287Z","comments":true,"path":"2018/08/29/Jenkins-Blue-Ocean-으로-배포하기/","link":"","permalink":"https://park-jihoon.github.io/2018/08/29/Jenkins-Blue-Ocean-%EC%9C%BC%EB%A1%9C-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/","excerpt":"","text":"Jenkins 란중요이슈Windows 10 환경에서 Jenkins 로 SSH 를 이용한 배포를 하기 위해서는 SSH KEY가 필요하다.원격지 서버에 ssh pub key 를 잘 등록하고Git Bash 에서도 비밀번호 없이 ssh 가 원활하게 접속되는것을 확인했지만 이상하게도 Jenkins 상의 shell script 에서는 ssh 접속 명령 이후 멈춰버리는 현상이 발생했다. Git Bash 로는 접속 가능 Jenkins Job 에서는 접속 불가 Blue Ocean 및 일반 Job 에서도 연결되지 않음. 원인을 파악하기 위해 비슷한 이슈를 구글링해보았지만 나오지 않았다… 해결ssh 에 -vvv 옵션을 준 뒤 jenkins Job을 실행했다.분명 SSH_Agent 를 사용했으며, SSH 인증 Credential 을 생성하여줬음에도 불구하고 id_rsa 파일을 엉뚱한 곳에서 찾으려고 노력하고 있었다. (털썩)ssh keygen 을 Git Bash 에서 진행했기 때문에 id_rsa 파일은 C:/Users/Park/.ssh 폴더에 들어있었지만 Jenkins 에서 검색중인 폴더는 C:\\\\WINDOWS\\\\system32\\\\config\\\\systemprofile/.ssh/ 였다. 이유가 뭐야…. C:/Users/Park/.ssh 내부의 파일을 복사 C:\\\\WINDOWS\\\\system32\\\\config\\\\systemprofile/.ssh/로 이동 해결완료.","categories":[{"name":"Tool","slug":"Tool","permalink":"https://park-jihoon.github.io/categories/Tool/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://park-jihoon.github.io/tags/Jenkins/"}]},{"title":"IntelliJ 단축키모음","slug":"Intellij-단축키모음","date":"2018-08-23T07:23:00.000Z","updated":"2019-11-26T16:55:00.692Z","comments":true,"path":"2018/08/23/Intellij-단축키모음/","link":"","permalink":"https://park-jihoon.github.io/2018/08/23/Intellij-%EB%8B%A8%EC%B6%95%ED%82%A4%EB%AA%A8%EC%9D%8C/","excerpt":"","text":"IntelliJ 단축키 모음기본적인 단축키 모음입니다.숙달되면 마우스 의존도가 좀 줄지 않을까 싶은데 맥과 윈도우를 모두 외우려니 여간 힘든게 아니군요… 맥을 버리면 편해지려나 java 개발자라면 강추 드리는 툴 입니다.","categories":[{"name":"Tool","slug":"Tool","permalink":"https://park-jihoon.github.io/categories/Tool/"},{"name":"IntelliJ","slug":"Tool/IntelliJ","permalink":"https://park-jihoon.github.io/categories/Tool/IntelliJ/"}],"tags":[{"name":"IntelliJ","slug":"IntelliJ","permalink":"https://park-jihoon.github.io/tags/IntelliJ/"}]},{"title":"[Git]Unlink of file Failed. Should I try again? 문제 해결법","slug":"git-Unlink-of-file-Failed-Should-I-try-again-문제-해결법","date":"2018-08-22T04:06:13.000Z","updated":"2019-11-25T14:50:11.286Z","comments":true,"path":"2018/08/22/git-Unlink-of-file-Failed-Should-I-try-again-문제-해결법/","link":"","permalink":"https://park-jihoon.github.io/2018/08/22/git-Unlink-of-file-Failed-Should-I-try-again-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EB%B2%95/","excerpt":"","text":"사건개요직장 후배가 eclipse의 synchronize git을 사용해 remote Server의 데이터를 pull 해오던 와중에 아무런 메시지 없이 데이터가 가져와지지 않는 현상이 발생했습니다.평소 eclipse를 사용하지 않는 관계로 툴 내부에서 확인이 어려웠고 결국 git bash 를 열었습니다. git bash우선 당겨와 보았습니다. 1$ git pull origin master 데이터를 잘 가져오던 중 아래의 메시지와 함께 멈춰버렸습니다. 1&gt; Unlink of file '파일명' failed. Should I try again? (y/n) 해결방안해당 문제는 보통 파일을 다른 프로그램이 사용중일 경우에 발생하며, 파일을 잡고있는 다른 응용프로그램을 우선 종료해야합니다. This could mean that another program is using the file, which is preventing git from “moving” the file into or out of the working directory when you are attempting to change branches. I have had this happen on Windows Vista where eclipse is the program “using” the file. The file may not be actually open in eclipse but may have been opened by a process run by eclipse. In this event, try closing the file in any applications that might have used it. If that doesn’t work, completely exit any applications which may have opened the file. stackoverflowunlink-of-file-failed-should-i-try-again 이것은 다른 프로그램이 파일을 사용하고 있다는 것을 의미 할 수 있습니다. 이는 git이 브랜치를 변경하려고 할 때 작업 디렉토리 안팎으로 파일을 “이동”하지 못하게합니다. 나는 Windows Vista에서 eclipse가 파일을 “사용”하는 프로그램을 사용하고있다. 파일은 이클립스에서 실제로 열리지 않을 수도 있지만 이클립스에서 실행되는 프로세스에 의해 열렸을 수 있습니다. 이 경우 파일을 사용한 적이있는 응용 프로그램에서 파일을 닫으십시오. 그래도 작동하지 않으면 파일을 열었을 수있는 응용 프로그램을 모두 종료하십시오. 마무리가장 의심스러웠던 후배 컴퓨터의 eclipse를 종료하였고. 다시 git pull 을 실행하자 diff 창이 정상적으로 떴으며, 문제가 해결되었습니다.이번 문제는 eclipse의 synchronize가 중간에 꼬이면서 발생한 것으로 보입니다. eclipse를 재실행 한 뒤에는 해당 문제가 발생하지 않았습니다.","categories":[{"name":"Git","slug":"Git","permalink":"https://park-jihoon.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://park-jihoon.github.io/tags/git/"}]},{"title":"CSRF 이해하기","slug":"CSRF-이해하기","date":"2018-08-20T07:44:43.000Z","updated":"2019-11-25T14:50:11.286Z","comments":true,"path":"2018/08/20/CSRF-이해하기/","link":"","permalink":"https://park-jihoon.github.io/2018/08/20/CSRF-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/","excerpt":"","text":"Express 팀의 csrf와csurf 모듈은 암호화 기능의 사용에 대해 의문을가지는 이슈가 자주 올라옵니다. 이는 CSRF 토큰이 작동하는 방식을 잘못 이해해서 발생하는의문이라고 생각합니다. 어째든, 빠르게 진실을 알아봅시다! 이 문서를 읽고, 질문이 있거나 무언가 잘못된 것이 있다고 생각하면 이슈를 생성하세요! CSRF 공격은 어떻게 하는거죠?공격자가 자신의 피싱 사이트에 다음과 같은 AJAX 버튼 또는 폼을 만들어 놓고 타겟의사이트로 위조 요청을 보냅니다: 123&lt;form action=\"https://my.site.com/me/something-destructive\" method=\"POST\"&gt; &lt;button type=\"submit\"&gt;여기를 누르면 공짜 돈을 드립니다!&lt;/button&gt;&lt;/form&gt; 이것이 문제가 되는 이유는 공격자가 AJAX 등을 통해 DELETE 메서드와 같은 요청을 원본사이트로 문제없이 보낼 수 있기 때문입니다. 만약 원본 사이트에서 세션 데이터나 중요한개인 정보를 다룬다면 아주 중대한 문제입니다. 만약 기술적인 지식이 전무한 사용자가이러한 상황을 만난다면 신용카드 정보 또는 사회 보장 정보를 입력할지도 모릅니다. CSRF 공격을 어떻게 방어하나요?JSON API만 사용제한된 CORS 환경에서 JavaScript를 통한 AJAX 호출만 사용합니다. 이 방법은 &lt;form&gt;이JSON 같은 정보를 전송할 수 없다는 점을 이용하여 요청 값을 JSON만 허용하는방법입니다. 이 방법은 상기한 형태의 폼을 통한 공격 가능성을 제거합니다. CORS 비활성화CSRF 공격을 배제하는 가장 첫 번째 방법은 cross-origin 요청을 비활성화하는 것입니다.만약 CORS를 허용하려면 사이드 이펙트(부수효과)를 발생시키지 않는 OPTIONS, HEAD, GET메서드만 허용시켜야 합니다. 불행히도, 위의 메서드를 통한 요청들은 JavaScript를 사용하지 않으므로 모두 차단되지않습니다. (따라서 CORS를 적용할 수 없습니다) 헤더의 레퍼러(referer) 확인불행히도, 레퍼러 헤더를 확인하는 것은 약간 좋지 않은 문제가 있습니다. 하지만 원본사이트가 아닌 해커의 사이트로부터 들어오는 요청은 언제나 막습니다. 이 방법은 문제가발생할 여지가 없습니다. 예를 들어, 레퍼러 헤더가 자신의 서버가 아닐 땐 세션을 로드할 수 없습니다. GET 메서드가 사이드 이펙트를 일으키지 않게하기GET 요청이 데이터베이스의 그 어떤 관련된 데이터도 변경할 수 없게 해야 합니다.이는 주로 초보자들이 많이 하는 실수이며 무려 어플리케이션의 CSRF 공격을 넘어서 수 많은공격을 가능하게 만듭니다. POST 사용 자제왜냐하면 &lt;form&gt;은 GET과 POST 메서드만 허용하기 때문입니다. 이러한 방식 대신PUT이나 PATCH, DELETE 같은 메서드를 사용하면 공격자가 사이트를 공격할 수 있는방법이 크게 줄어듭니다. Method Override 사용하지 않기많은 어플리케이션들이 기본 폼에 PUT 과 PATCH, DELETE 요청을 지원하기 위해method-override를 사용합니다.하지만, 이것은, 요청을 완전히 취약점이 없는 취약점으로 변경했습니다. 그러니 어플리케이션에 method-override를 사용하지말고 그냥 AJAX를 쓰는게 낫습니다. 오래된 브라우저는 지원하지 않기오래된 브라우저는 CORS와 보안 정책을 지원하지 않습니다. 단순히 오래된 브라우저(주로기술적인 지식이 부족한 컴맹들이 사용하며, 이들은 공격하기 더 쉽습니다)의 지원을 끊는것 만으로도 CSRF 공격 경로를 최소화 할 수 있습니다. CSRF 토큰UNBEKNOWN아아, 마지막 해결법은 바로 CSRF 토큰을 사용하는 것입니다. CSRF 토큰이 어떻게작동하냐구요? 서버가 클라이언트로 토큰을 전송합니다. 클라이언트가 폼을 토큰과 함께 제출합니다. 토큰이 올바르지 않으면 서버에서 요청을 거부합니다. 공격자는 타겟 사이트에서 CSRF 토큰을 얻는 방법을 찾으려 할 것이고 이 때 JavaScript를쓸 것입니다. 따라서 사이트가 CORS를 지원하지 않는다면 공격자가 CSRF 토큰을 얻을 수있는 방법이 없습니다. 취약점을 제거하세요. 반드시 AJAX를 통해 CSRF 토큰에 접근할 수 없도록 하세요!/csrf 같이 바로 토큰을 받아올 수 있는 라우트는 만들지 말고, 특히 그 라우트에 CORS를지원하지 마세요. 토큰은 추측할 수 없어야 하며, 이렇게 하면 공격자가 몇 번의 시도만으로 토큰을 얻기힘들어집니다. 또한, 따로 암호학적인 보안이 필요하지 않습니다. 공격은 서버의 브루트 포스공격이 아닌 사용자가 모르는 사이에 한두 번의 클릭으로 이루어집니다. BREACH 공격여기선 salt를 함께 제공해야 합니다. BREACH 공격은 아주 간단합니다: 만약 서버가HTTPS+gzip를 통해 같거나 비슷한 응답을 여러 번 한다면, 공격자는 응답 본문의 컨텐츠를예측할 수 있습니다. (HTTPS를 완전히 쓸모없게 만듭니다) 해결법? 각 응답을 약간씩 다르게만들면 됩니다. 그러므로, CSRF 토큰은 각 요청을 기준으로 매번 다르게 생성됩니다. 하지만 서버는각 요청에 포함된 토큰이 유효한지 확인할 수 있어야 합니다: 암호학적으로 안전한 CSRF 토큰은 이제 서버에 의해서만 알려진, (가정) CSRF“비밀”입니다. 이제 CSRF 토큰은 secret과 salt의 해시입니다. 추가적인 내용은 다음을 참고하세요: BREACH CRIME BREACH 공격에 대한 방어 [Salt란?][2] 안전한 패스워드 저장 (한국어) 참고로 CSRF은 BREACH 공격을 해결 하지 않습니다. 하지만 모듈은 간단히 요청을무작위화 시켜 BREACH 공격을 완화시켜줍니다. Salt는 안전한 암호화를 할 필요가 없습니다왜냐하면 클라이언트는 salt를 알고 있기 때문입니다!!!서버는 &lt;salt&gt;;&lt;token&gt;를 전송할 것이고 클라이언트는 서버로 같은 값을 요청에 포함하여보낼 것 입니다. 그리고 서버는 &lt;secret&gt;+&lt;salt&gt;=&lt;token&gt;이 맞는지 확인할 것입니다.salt는 반드시 토큰과 함께 전송되어야 합니다. 이렇지 않다면 서버는 토큰이 확실한지확인할 수 없습니다. 이것은 간단한 암호학적인 방법입니다.더 많은 방법들이 있지만 더 복잡하며 이 문제에 대해 효과적이지 않습니다. 토큰 생성은 빨라야 합니다!왜냐하면 토큰은 매 요청마다 생성되어야 하기 때문입니다!이 작업은 간단히 Math.random().toString(36).slice(2) 이렇게만 해도 충분하며뿐만 아니라 매우 고성능입니다! 각 요청에 대해 OpenSSL과 같은 암호학적으로 암호화된토큰은 필요하지 않습니다. secret(데이터)은 비밀일 필요가 없습니다하지만 이것은. 데이터베이스를 사용하는 세션 스토어를 쓴다면 클라이언트는 절대 DB에저장된 secret을 읽을 수 없습니다. 하지만 쿠키 세션을 사용한다면 secret은 쿠키에저장되고 클라이언트에게 보내질 것입니다. 그러므로, 쿠키 세션이 httpOnly를사용하도록 하고 클라이언트가 secret을 client-side JavaScript로 읽을 수 없도록 해야합니다! CSRF 토큰을 잘못 사용하는 경우JSON AJAX 요청에 CSRF 토큰을 사용전술했듯이, 만약 CORS를 지원하지 않고 API가 JSON에 한정되어 있다면, AJAX 요청엔CSRF 토큰을 포함시킬 수 있는 방법이 없습니다. CSRF 토큰을 AJAX로 전송어플리케이션에 GET /csrf 같은 라우트는 절때 만들어선 안되며 CORS를 활성화해서도안됩니다. CSRF 토큰을 API 응답 본문에 포함하여 전송하면 안됩니다. 결론최근 웹은 점점 JSON API를 사용하는 추세이며 브라우저는 더 많은 보안 정책으로 더안전해지고 있기에 CSRF의 중요성은 점점 떨어지고 있습니다. 오래된 브라우저의 사이트접속을 차단하고 많은 사이트 API를 JSON API로 변경하면 근본적으로 CSRF 토큰을 사용할필요가 없어집니다. 그러나 안전을 위해, 언제든 가능할 때, 특히 구현에 사소한 상황이아닐 경우 여전히 이것들을 구현하는 것이 좋습니다. 오타나 오역이 있을 수 있습니다. 문제를 발견했다면, 수정해서 PR을 넣어주세요. 많은도움이 됩니다!","categories":[],"tags":[]},{"title":"Burp suite 간단사용법","slug":"Burp-suite-간단사용법","date":"2018-08-19T06:03:14.000Z","updated":"2019-11-25T14:50:11.286Z","comments":true,"path":"2018/08/19/Burp-suite-간단사용법/","link":"","permalink":"https://park-jihoon.github.io/2018/08/19/Burp-suite-%EA%B0%84%EB%8B%A8%EC%82%AC%EC%9A%A9%EB%B2%95/","excerpt":"","text":"프록시 서버 설정프록시서버서버와 클라이언트 사이에서 중계기 역할을 수행하며 대리로 통신하는 기능을 프록시(Proxy) 라고 합니다. 프록시 서버란 해당 중계기능을 지원하고 있는 서버(컴퓨터) 혹은 응용프로그램 을 말합니다. Burp Suite 사용을 위해서는 우선 프록시 서버를 설정할 필요가 있습니다. 이번 포스팅에서는 Windows 10 / Chrome 환경에서 프록시 서버를 생성해보겠습니다. Chrome의 설정 화면을 열어줍니다. chrome://settings/ 고급 설정 하단의 프록시 설정 열기 를 클릭해줍니다. 인터넷 속성에서 LAN 설정을 클릭합니다. 프록시 서버 란에 체크한 뒤 로컬 서버 ip 인 127.0.0.1 을 넣어주고, Burp Suite 의 기본 포트인 8080 을 설정해줍니다. 프록시 서버 설정이 완료되었습니다. Burp Suite Proxy 확인Burp Suite 프로그램의 설치는 이전 포스트를 참고해주세요. 프록시 서버 설정을 완료한 뒤 Burp Suite 프로그램을 실행합니다. proxy 탭에서 Intercept is off 를 클릭하여 Intercept is on 으로 변경합니다. on 인 동안에는 Chrome 을 통한 브라우징이 모두 Burp Suite 를 통해야만 진행될 수 있게됩니다. 필요에 따라 On / Off 하면서 사용하면 됩니다. 주의 : Chrome 자체적으로 위험한 Proxy 를 감시하는 기능이 존재합니다. 외부 인터넷 연경 (Google 검색 등)에 제한이 있을 수 있습니다. 주요 옵션proxy패킷을 의도한 대상에 도달 하지 않게 하거나 특정 호스트에 redirect 하거나, 패킷을 삭제할 수도 있습니다. spiderspider 기능은 새 링크, 콘텐츠 등을 찾는 데 사용 됩니다. 로그인 폼을 찾으면 자동으로 전송하고, response를 통해 새로운 contents를 찾습니다. 이 정보는 scanner 로 보내져서, 찾아낸 모든 link와 content에 대해 scan을 하게 됩니다. scanner웹 응용 프로그램을 scan하여 취약점을 찾는데 사용 됩니다. 검사의 종류는 passive, active, user-directed가 있습니다. 몇 가지 false positives가 테스트 하는 동안 발생할 수 있습니다. 자동화된 스캐너에는 100% 정확한 결과가 없음을 기억하는 게 중요합니다. 불행하게도 무료 버전으로는 scanner 기능이 제공되지 않습니다. intruder이 기능은 브루트 포스 공격을 수행하거나 웹 응용 프로그램을 fuzzing하거나, 취약점을 exploite하는 것과 같은 다양한 목적을 위해 사용할 수 있습니다. repeater이 기능은 같은 요청을 많은 횟수로 수정해서 보내서, 응답을 분석할 때 사용 됩니다. sequencer이 기능은 주로 웹 응용 프로그램에서 제공 하는 세션 토큰의 임의성을 확인 할 때 사용 됩니다. 이것을 알아내기 위해 다양한 고급 테스트를 수행 합니다. decoder이 기능을 사용하여 암호화된 데이터를 다시 원래 형태로 해독하거나, 데이터를 암호화 하기 위하여 사용할 수 있습니다. comparer이 기능은 두 개의 요청, 응답 또는 다른 형태의 데이터 비교를 수행하는 데 사용됩니다. 이 기능은 다른 입력에 대한 응답을 비교 하는 경우에 유용할 수 있습니다.","categories":[{"name":"Tool","slug":"Tool","permalink":"https://park-jihoon.github.io/categories/Tool/"}],"tags":[{"name":"Burp","slug":"Burp","permalink":"https://park-jihoon.github.io/tags/Burp/"}]},{"title":"Burp suite 설치","slug":"Burp-suite-설치","date":"2018-08-18T05:10:10.000Z","updated":"2019-11-25T14:50:11.286Z","comments":true,"path":"2018/08/18/Burp-suite-설치/","link":"","permalink":"https://park-jihoon.github.io/2018/08/18/Burp-suite-%EC%84%A4%EC%B9%98/","excerpt":"","text":"Burp Suite 란Burp or Burp Suite is a graphical tool for testing Web application security. The tool is written in Java and developed by PortSwigger Security. wikipediaBurp Suite Burp Suite는 웹 애플리케이션의 보안 테스트를 돕기위한 그래픽 툴 입니다. 다양한 기능을 제공하지만 유료인 Pro 버전이 존재하며 수동으로 테스트 해볼 수 있게 나온 Community 버전이 존대합니다.Pro를 구매할 이유가 없는 관계료 오늘 살펴볼 버전은 Community 버전입니다.주의 : Community 버전은 프로젝트를 저장할 수 없습니다. 두고두고 테스트를 진행해야 한다면 좋은 선택이 아닐 수 있습니다. Burp_suite 다운로드 및 설치다운로드 경로 : https://portswigger.net/burp/communitydownload java 기반으로 제작된 jar 버전이 있으며, windows 일 경우 exe 버전을 다운로드 받아 install 할 수도 있습니다. 원하는 버전을 다운로드 합니다.글에서는 windows 버전을 기준으로 설치하겠습니다. 다운로드가 완료되었다면 burpsuite_community_windows-x64_v1_7_36.exe 와 유사한 파일이 저장됩니다. 더블클릭 합니다.관리자 권한이 필요합니다. windows 버전은 설치가 간단합니다. (사실 java 버전은 설치조차 필요 없을 수도 있겠지만요…) 좋은설치 = 넥스트 고고! Burp Suite 실행시작메뉴에 생성된 Burp Shute 를 실행합니다. 잠시간의 로딩 후 아래의 화면을 만나게 됩니다. 프로젝트 정보 등을 저장할 수 없는 임시 프로젝트만 지원한다는 이야기 입니다. 아쉽지만 다음 화면으로 갑시다. Community 버전의 한계 첫 실행이므로 별다른 설정이 존재할리 없습니다. default 설정을 선택하고 다음 화면으로 갑니다. 성공적으로 첫 실행화면이 출력되었습니다. 다음 시간에는 Tool 을 이용한 간단한 XSS 테스트를 진행해보겠습니다.","categories":[{"name":"Tool","slug":"Tool","permalink":"https://park-jihoon.github.io/categories/Tool/"}],"tags":[{"name":"Burp","slug":"Burp","permalink":"https://park-jihoon.github.io/tags/Burp/"}]},{"title":"Selenium을 이용한 Web Crawler 만들기","slug":"Selenium을-이용한-Web-Crawler-만들기","date":"2018-08-09T02:15:50.000Z","updated":"2019-11-25T14:50:11.287Z","comments":true,"path":"2018/08/09/Selenium을-이용한-Web-Crawler-만들기/","link":"","permalink":"https://park-jihoon.github.io/2018/08/09/Selenium%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-Web-Crawler-%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"Selenium 이란?Selenium automates browsers. SeleniumHQWhat is Selenium? Selenium은 webdriver를 통해 웹 브라우저(ie, chrome, firefox 등)를 자동화 하여 웹 에플리케이션을 테스트 할 수 있는 오픈소스 프레임워크입니다.다양한 언어 (c#, java, python) 를 지원하며, 상황에 맞게 골라 사용할 수 있죠. Selenium에는 Selenium WebDriver 와 Selenium IDE 가 있습니다. Selenium WebDriverSelenium WebDriver는 지금은 사용되지 않는 Selenium Remote Control의 후속제품으로 다음과 같은 기능이 필요할 경우 사용이 추천됩니다. 브라우저 기반의 강력한 반복 자동화 테스트 생성 여러 환경에서 Script를 확장 및 배포 Selenium IDESelenium IDE는 Firefox 의 확장프로그램(add-on)으로 간단히 recode 및 playback을 사용할 수 있습니다.다음과 같은 기능이 있을 경우 사용이 추천됩니다. 빠른 버그 복제 스크립트 작성 자동화 된 예비 검사를 돕기위한 스크립트 작성 이번에 제작하려는 프로그램은 Web Crawler이기 때문에 IDE 는 다음기회에 살펴보기로 하고 Selenium WebDriver를 살펴보기로 합니다. Selenium + pythonSelenium은 많은 언어를 지원하지만 python 을 기반으로 살펴보겠습니다.간단한 프로젝트를 만들때 python 을 사용하는 이유는 다음과 같습니다. 비교적 짧은 코드로 얻을 수 있는 만족스러운 결과물 복잡하지 않은 작은 규모의 Application 을 제작하기에 적합 파워풀한 Beautifulsoup jar 로 배포 시 사용하기 힘들어 하는 사용자가 존재 =&gt; 배포시 간단히 exe 로 변환 가능 python requests Crawler와의 차이점사실 이전부터 사용해오던 간단한 Web Crawler가 존재했습니다.python 기반으로 가장 쉽게 제작할 수 있는 Beautifulsoup과 requests를 이용한 Crawler였죠. 기능은 간단했습니다. 목표 사이트에 로그인 원하는 커뮤니티로 이동 게시물목록을 읽어들여 게시물 내부의 이미지를 모두 다운로드 해당 프로그램은 약 1년 이상 안정적으로, 또한 성공적으로 그 역할을 완수했습니다. 하지만 최근 해당 사이트의 업데이트로 로그인 보안 강화라는 어쩔 수 없는 이유가 발생하게 됩니다.requests의 로그인 방식은 id와 password를 해당 사이트에 parameter 로 날려서 로그인 세션을 생성해오게 됩니다.로그인 세션을 발생시키는 url을 확인 후 해당 페이지가 원하는 parameter를 보내주는 방식인거죠. 하지만 이번 업데이트에서는 복잡한 javascript 라이브러리로 사용자의 password와 server 에서 보낸 1회성 key를 조합하여 암호화한 parameter를 넘겨야만 Session이 생성되도록 변경되었습니다. requests 기반 Crawler의 한계를 느끼는 순간이었습니다. javascript function 이용의 필요성사이트 로그인방식은 사실 간단합니다. id 와 pw 를 입력하는 란에 알맞게 넣은 뒤 로그인 버튼을 클릭해주면 되죠. 그 뒤의 복잡한 javascript 구동방식이라던가, 암호화 과정은 고려할 필요가 없습니다.Selenium 역시 사용자가 입력하는 것 처럼 적절히 입력하고 클릭이벤트를 발생시켜 줍니다.requests는 문자 형식으로 넘어온 html을 분석하기 때문에 javascript function을 실행시킬 수 없었다면, Selenium은 브라우저 자체를 이용하기 때문에 javascript function 까지도 충분히 이용이 가능합니다. 어라… 뭔가 더 좋은게 아닌가? 다만 속도적인 측면에서는 무조건 requests가 빨랐습니다. 아무래도 브라우저가 해당 페이지를 읽어들이는데 필요한 시간이 존재하기 때문이겠지요. Selenium 설치본 포스트는 python 3.5가 이미 설치되어 있는 환경이라고 가정하에 작성됩니다. 많은 호환성이 걱정되신다면 Anaconda 환경에서 python 3.5 를 추가하여 사용하시기를 추천드립니다. 1pip install selenium 설치는 간단히 완료되었습니다. 또한 실제 브라우저가 필요하므로 chrome이 설치되지 않았다면 빠르게 설치를 진행해줍니다. 다음은 Chrome 기반으로 작성된 Webdriver 인 ChromeDriver 를 다운로드 받아줍시다. URL : https://sites.google.com/a/chromium.org/chromedriver/downloads 준비 완료! 라이브라리 import우선 필요한 라이브러리들을 import 해줍니다. 1234import os from selenium import webdriver from selenium.webdriver.chrome.options import Options from selenium.webdriver.common.keys import Keys selenium.webdriver.common.keys는 실제로 사용자가 입력하는 key 이벤트를 발생시키기 위한 라이브러리 입니다.ID와 PW를 입력해 줘야 하니 import 합니다. 다음은 Chrome 구동시 옵션입니다. --headless 를 부여하면 chrome 이 백그라운드에서 동작하며 좀더 속도가 향상됩니다. (headless 모드는 chrome 버전 63 부터 사용 가능합니다.)ChromeDriver를 제작중인 py 파일과 동일한 폴더로 이동시킨 뒤에 해당 Path 를 잡아줍니다. 1234chrome_options = Options() chrome_options.add_argument(\"--headless\") chrome_options.binary_location = 'C:/Program Files (x86)/Google/Chrome/Application/chrome.exe' driver = webdriver.Chrome(executable_path=os.path.abspath(\"chromedriver\"), chrome_options=chrome_options) Chrome을 구동합니다. 1driver.get(\"https://logins.daum.net/accounts/loginform.do\") 해당 페이지가 로드된 뒤 로그인 정보를 입력하고 로그인 버튼을 클릭 합니다. 123456789101112my_id = driver.find_element_by_id(\"id\") #아이디를 입력할 input 위치my_pw = driver.find_element_by_id(\"inputPwd\") #비밀번호를 입력할 input 위치login_button = driver.find_element_by_id(\"loginBtn\") #로그인버튼if login_button.is_displayed(): my_id.clear() my_id.send_keys(\"아이디\") my_pw.clear() my_pw.send_keys(\"패스워드\") login_button.click()driver.quit() my_id.clear()로 혹시나 있을지 모르는 초기값을 제거해준 뒤 my_id.send_keys(&quot;아이디&quot;) 해당 구문을 지정된 input 에 입력해줍니다. 입력이 완료되었다면 login_button.click()으로 로그인을 진행합니다. driver.quit()는 Chrome을 종료시키는 구문입니다. 프로그램이 완료된 뒤 Chrome 이 종료되기를 원한다면 잊어버리면 안됩니다. (특히 headless의 경우 눈에보이지 않기 때문에 자칫하다가 어마어마하게 실행되어버리는 경우가 발생합니다.) 마무리하며Selenium은 requests보다 러닝커브가 높은편입니다. 또한 다른 사용자를 위해 제작한 프로그램을 exe로 배포하더라도 chrome 과 chromedriver 를 별도로 다운로드 받아야 하는 등의 불편점도 존재합니다.하지만 훨씬 강력하며, 매력적인 프레임워크임에는 틀림없어 보입니다.","categories":[{"name":"Python","slug":"Python","permalink":"https://park-jihoon.github.io/categories/Python/"},{"name":"Selenium","slug":"Python/Selenium","permalink":"https://park-jihoon.github.io/categories/Python/Selenium/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://park-jihoon.github.io/tags/Python/"},{"name":"Selenium","slug":"Selenium","permalink":"https://park-jihoon.github.io/tags/Selenium/"}]},{"title":"[Oracle] Row to Column, 행을 열로 합치기","slug":"Oracle-Row-to-Column-행을-열로-합치기","date":"2018-08-09T01:30:46.000Z","updated":"2019-11-25T14:50:11.286Z","comments":true,"path":"2018/08/09/Oracle-Row-to-Column-행을-열로-합치기/","link":"","permalink":"https://park-jihoon.github.io/2018/08/09/Oracle-Row-to-Column-%ED%96%89%EC%9D%84-%EC%97%B4%EB%A1%9C-%ED%95%A9%EC%B9%98%EA%B8%B0/","excerpt":"","text":"여러 행을 특정 구분자(예:콤마[,])로 구분하며 합쳐야할 경우 사용되는 SQL 이다. 123456789SELECT (SUBSTR (SYS_CONNECT_BY_PATH (PART_NM , ','), 2)) csv FROM ( SELECT X.PART_NM , ROW_NUMBER () OVER (ORDER BY X.PART_NM ) rn, COUNT (*) OVER () cnt, X.NFIX_REQ_NO FROM Table_One X ) WHERE rn = cntSTART WITH rn = 1CONNECT BY rn = PRIOR rn + 1 결과 : 콤마로 구분지어져 한줄로 출력된다.","categories":[{"name":"Database","slug":"Database","permalink":"https://park-jihoon.github.io/categories/Database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://park-jihoon.github.io/tags/Oracle/"}]},{"title":"Equal Join의 대표적인 3가지","slug":"Equal-Join의-대표적인-3가지","date":"2018-08-08T01:24:44.000Z","updated":"2019-11-25T14:50:11.286Z","comments":true,"path":"2018/08/08/Equal-Join의-대표적인-3가지/","link":"","permalink":"https://park-jihoon.github.io/2018/08/08/Equal-Join%EC%9D%98-%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-3%EA%B0%80%EC%A7%80/","excerpt":"","text":"오라클 기준으로 작성된문서이지만 원리및 장단점을 쉽게 설명했기에 올려봅니다. 개요관계형 데이터 베이스에서 데이터 연결 방법 중 Join의 종류, 조인의 수행원리, 각 조인의 특징, 그리고 조인별 선택기준에 대해서 소개하고자 한다. Join 정의조인은 두 집합간의 곱으로 데이터를 연결하는 가장 대표적인 데이터 연결 방법이다.종류에는 Nested Loop Join, Sort Merge Join 그리고 Hash Join이 있다.1 * M = M 과 M * 1 = M 의 결과집합이 동일한 것처럼 Optimizer가 3가지의 조인 중 어떤 것을 선택할지라도 결과집합은 동일하다. 하지만 수행속도 측면에서 본다면 조인하고자 하는 두 집합의 데이터 상황에 따라 어떤 조인을 선택하느냐, 어떤 집합을 먼저 선행하느냐 에 따라 수행속도에 미치는 영향은 크다. 수행원리100쌍의 남녀가 사랑의 짝대기 하는 것에 비추어 3가지 조인방식이 수행되는 원리를 설명해 보자. 남녀 모두는 자기가 원하는 상대방의 번호표 하나씩 가지고 있고, 한 사람은 여러 사람으로부터 선택 받을 수 있다. Nested Loop JoinNested Loop Join은 선행집합의 처리 범위가 결정되어 지면 후행집합의 일량이 정해지는 종속적 방식이다. 첫번째 여자는 자기가 선택한 번호표를 가지고 처음부터 차례로 남자의 번호를 확인하고, 해당 번호의 남자가 자기를 선택했는지 확인한다.그리고 두 번째, 세 번째…백 번째 여자까지 같은 작업을 반복 수행하게 된다.이처럼 선행 집합의 선두부터 차례로 후행집합과 조건을 비교 하면서 선행집합의 처리범위가 끝날 때 까지 같은 작업을 반복하는 것이 Nested Loop Join이다. 특징 및 사용기준온라인 어플리케이션에서 주를 이루는 Nested Loop Join은 부분범위 처리나 사용자가 데이터를 요구 했을 때짧은 시간에 결과를 볼 수 있는 적은 데이터를 액세스 할 때 쓰인다. 다음과 같은 SQL을 예로 들어 보자. 12345SELECT a.FLD1, ..., b.FLD1,... FROM TAB2 b, TAB1 aWHERE a.KEY1 = b.KEY2 AND b.FLD2 like 'A%' AND a.FLD1 = '10' 조인 컬럼인 a.KEY1 = b.KEY2 에 양쪽 테이블 모두 인덱스가 존재하고,선행 테이블을 TAB1으로 했을 때와 TAB2로 했을 때의 수행횟수를 비교하여 보자. TAB1이 선행테이블 일때 1 a.FLD1 인덱스 5000건 Range Scan. 2 Rowid로 TAB1에 5000회 랜덤액세스 3 성공/실패에 상관없이 b.KEY2 인덱스에 5000회 랜덤액세스 및 조인시도 4 조인에 성공한 Rowid로 TAB2에 100회 랜덤액세스 5 b.FLD2 like &#39;A%&#39; 체크 후 성공한 50건 운반단위 이동 TAB2가 선행테이블 일때 1 b.FLD2 인덱스 100건 Range Scan. 2 TAB2의 100회 랜덤액세스 3 성공/실패에 상관없이 a.KEY1 인덱스에 100회 랜덤액세스 및 조인시도 4 조인에 성공한 Rowid로 TAB1에 70회 랜덤액세스 5 a.FLD1 = &#39;10&#39; 체크 후 성공한 50건 운반단위 이동 결과건수는 두 가지 수행방식 동일하게 50건이지만, 수행횟수 측면에서 본다면 TAB1을 선행테이블 했을 때는 5000회의 조인시도가 발생하였고,TAB2를 선행테이블로 했을 때는 100회의 조인시도가 발생하였다.이처럼 조인 순서 및 선행 테이블의 처리범위에 따라서 수행횟수는 크게 달라질 수 있다. 특징 선행 테이블의 처리범위가 일량을 결정한다.(방향성) 선행 테이블의 값을 받아서 후행 테이블의 처리범위가 결정된다.(종속적) 주로 랜덤 액세스 방식으로 처리된다.(랜덤액세스) 후행 테이블의 조인컬럼의 인덱스의 유무 및 조건의 인덱스 참여의 정도에 따라 수행속도가 많이 차이 난다.(연결고리 상태) 사용기준 부분범위처리를 하는 경우에 유리하다. 처리량이 적은 경우에 유리하다.- 랜덤액세스가 많을 경우 수행속도를 보장할 수 없으므로 Sort Merge Join이나 Hash Join으로 유도 선행 테이블의 결과를 받아야만 후행 테이블의 처리범위를 줄일 수 있는 경우에 유리하다. - 연결고리에 Index가 반드시 존재하여야 함 선행 테이블의 처리범위가 수행속도에 절대적 영향을 미치므로 최적의 조인 순서가 될 수 있도록 유도해야 한다. Sort Merge JoinSort Merge Join은 처리범위를 결정하는데 독립적이다. 남녀는 각각 자기가 선택한 상대방의 번호표(Join Key) 순으로 각각 줄(Sort)을 선다.그러면 중간의 아나운서가 차례로 양쪽의 번호표가 일치하는지를 확인하면서 번호표가 맞다면 짝을 지어줄 것이다.이처럼 각각의 집합은 자기에게 주어진 조건으로 처리범위를 결정하고, 조인 컬럼으로 각각 Sort 한 후 조인하는 방식이 Sort Merge Join이다. 특징 및 사용기준다량의 데이터를 스캔방식으로 처리하는 Sort Merge Join은 양쪽테이블을 각자 액세스하여 처리 범위를 줄이고,조인컬럼 순으로 데이터를 Sort 후에 조인하는 방식이다. 12345SELECT a.FLD1, ..., b.FLD1,... FROM TAB2 b, TAB1 aWHERE a.KEY1 = b.KEY2 AND b.FLD2 like 'A%' AND a.FLD1 = '10' 수행 과정1 a.FLD1 인덱스 Range Scan.2 Rowid로 TAB1에 랜덤액세스3 조인컬럼인 a.KEY1로 SORT4 b.FLD2 인덱스 Range Scan.5 Rowid로 TAB2에 랜덤액세스6 조인컬럼인 b.KEY2로 SORT 한다.7 양쪽 집합을 Scan하면서 a.KEY1 = b.KEY2 조인 시도8 성공한 Row 운반단위 이동 수행과정에서 나타나듯이 Nested Loop Join과 달리 상대 테이블의 결과에 의해 처리범위가 결정되는게 아니라스스로에게 주어진 조건 만으로 처리범위를 줄인 후 Sort하게 되므로, 조인 컬럼으로 이루어진 인덱스는 사용하지 않게 된다. 특징 상대 테이블로부터 결과 값을 제공받지 않고, 자신에게 주어진 조건으로만 처리범위를 결정한다.(독립적). 각자 SORT후에 조인을 하게 되므로 부분범위 처리가 아닌 전체범위 처리를 하게 된다.(전체범위 처리) 조인의 순서에는 상관없다.(무방향성) 인덱스가 아닌 컬럼도 Merge할 작업 대상을 줄이므로 중요한 의미를 가진다. 사용기준 처리량이 많거나 전체범위 처리 시에 유리하다. 랜덤액세스가 많은 Nested Loop Join은 불리 스스로 자신의 처리범위를 많이 줄일 수 있을 때 유리하다. 연결고리 이상 상태에 영향을 받지 않으므로 연결고리 컬럼을 위한 인덱스를 생성하지 않고도 유용하게 사용할 수 있다. 처리할 데이터량이 적은 온라인 어플리케이션에서는 Nested Loop Join이 유리한 경우가 많으므로 Sort Merge Join은 주의하여 사용한다. Hash JoinHash Join 역시 처리범위를 결정하는데 독립적이다. 1번부터 100번(Hash Table)의 푯말이 있다.여자측은 자기가 가지고 있는 상대방의 번호표 숫자푯말 앞에 서는 것이다(Hash Function).물론 각 푯말에는 여러 명의 여자가 서 있을 수도, 한명도 없을 수도 있다.다음으로 남자는 자기 번호푯말 앞으로 가서 남자가 가지고 있는 번호와 상대 여성의 번호와 맞는지를 비교하면 된다. 이처럼 선행 집합은 Hash Function을 이용하여 Hash Table을 구성하고,후행집합은 차례로 Hash Function을 이용하여 Hash Table을 탐침하는게 Hash Join 수행 원리다. 특징 및 사용기준대량의 데이터를 액세스하는 작업에서는 시스템 리소스를 많이 사용하는 대신 짧은 시간에 보장할 수 있어야 한다. 12345SELECT a.FLD1, ..., b.FLD1,... FROM TAB2 b, TAB1 aWHERE a.KEY1 = b.KEY2 AND b.FLD2 like 'A%' AND a.FLD1 = '10' 수행 과정1 두 테이블 중 적은 테이블을 선행 테이블로 결정한다.2 선행 테이블을 Hash Function을 이용하여 Hash Area에 Hash Table을 구성한다.(Build Input)3 만약 Hash Area만으로 생성 가능하다면 후행테이블은 크기에 상관없이 차례로 Hash Function을 이용하여 Hash Table과 조인(Probe Input)하면서 성공한 결과값을 운반단위로 이동한다.4 만약 Hash Area만으로 Hash Table 생성이 불충분 하다면 Hash Table Overflow가 발생하여 데이터를 나눠서 저장 할 Partition 수를 결정한다.(Fan -out)5 선행 테이블의 조인 컬럼과 Select List 컬럼을 메모리로 읽어 들여 첫번째 해쉬 함수를 이용하여 Partition을 Mapping하고, 두번째 해쉬 함수를 이용하여 해쉬 테이블 생성시 사용 할 해쉬 값을 생성한다.6 선행 테이블의 조인 컬럼의 유일 값만으로 Bit-Vector을 생성한다. (추후 Bit-Vector filtering에 사용하기 위함.)7 Partition에 데이터를 MOVE하고 채워진 Partition은 디스크로 내려간다.8 선행 테이블이 모두 읽혀지면 Partition 테이블을 완성하고, Partition 크기순으로 정렬한 후 작은 Partition N개를 메모리에 로드한다.9 후행 테이블을 읽으면서 조인컬럼으로 Bit-Vector와 Filtering에 성공하였다면, 첫번째 해쉬함수로 Partition을 결정하고, 두번째 해쉬 함수를 이용하여 메모리 상에 있는 선행테이블과 조인하고 성공하면 운반단위로 이동하고, 해당 Partition이 메모리에 존재하지 않는다면 해쉬 키값,조인컬럼, Select List를 디스크에 쓴다.10) 후행 테이블이 모두 읽혀지면, Bit-Vector Filtering에 성공했지만, 조인에 성공하지 못해 미 처리된 선행 파티션과 후행 파티션을 메모리에 올려 차례로 반복수행 한다. 액세스해야 할 데이터가 많을 경우 Sort Merge Join은 Merge 단계에 들어 가기 위해 양쪽 테이블의 처리 범위가 SORT 되어야 하므로 SORT에 대한 부담이 크고,Nested Loop Join은 선행 테이블의 처리 범위가 넓을 경우 그 만큼 랜덤 액세스의 발생으로 수행속도를 보장할 수 없다.이에 반해 Hash Join은 다른 조인에 시스템 리소스를 가장 많이 사용하지만 Hash Function을 이용함으로써 Sort를 하지 않고,각 테이블에 한번만 액세스하여 조인이 이루어 지므로 큰 테이블간이나, 큰 테이블과 적은 테이블의 조인에 효율적인 조인 방법이다. 특징 다른 테이블의 결과 값을 제공받지 않고, 자신에게 주어진 조건으로만 처리범위를 결정한다.(독립적). 해쉬 함수를 이용 하게 되므로 부분범위 처리를 할 수 없으며 전체범위 처리를 하게 된다.(전체범위 처리) 메모리 영역만으로 해쉬 테이블을 생성시 최적의 효과를 낼 수 있으므로 적은 테이블이 선행으로 온다. 해쉬 함수를 이용하므로 결과값의 정렬을 보장 받을 수 없다. 사용기준 대량의 데이터 액세스 시, 배치 처리, Full Table Scan 하면서 조인 해야 할 때 유리하다. 비용은 많이 들지만 수행속도를 보장해야 하는 작업에 유용하다.(Parallel Query 사용) 가능한 메모리 내에서 작업 가능하도록 init Parameter나 Session 정보를 변경하여 사용한다. (Hash_area_size, Hash_multiblock_io_count 등..) 마무리수행속도는 시스템 리소스와 즉결된다. 사용자는 작업의 성격을 분명히 하고, 작업에 맞는 조인은 선택하여야만 수행 속도를 보장할 수 있다.SQL작성 후 반드시 실행계획를 확인 하여 Optimizer가 사용자가 원하는 액세스를 하는 확인하는 습관을 들어야 한다.","categories":[{"name":"Database","slug":"Database","permalink":"https://park-jihoon.github.io/categories/Database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://park-jihoon.github.io/tags/Oracle/"}]}]}