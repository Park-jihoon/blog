<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | Jihoon&#39;s IT Development | Web Developer&#39;s Hobby Development Notes</title>

  
  <meta name="author" content="Park-JiHoon">
  

  
  <meta name="description" content="평소 개발이 취미인 개발자의 마구잡이 정리노트">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Jihoon&#39;s IT Development"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Jihoon&#39;s IT Development" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Jihoon&#39;s IT Development</a>
    </h1>
    <p class="site-description">Web Developer&#39;s Hobby Development Notes</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/18/Burp-suite-설치/"><span>Burp suite 설치</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/18/Burp-suite-설치/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-18T05:10:10.000Z">
          2018-08-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="Burp-Suite-란"><a href="#Burp-Suite-란" class="headerlink" title="Burp Suite 란"></a>Burp Suite 란</h3><blockquote><p>Burp or Burp Suite is a graphical tool for testing Web application security. The tool is written in Java and developed by PortSwigger Security.</p>
<footer><strong>wikipedia</strong><cite><a href="https://en.wikipedia.org/wiki/Burp_suite" target="_blank" rel="noopener">Burp Suite</a></cite></footer></blockquote>

<p><a href="https://portswigger.net/burp" target="_blank" rel="noopener">Burp Suite</a>는 웹 애플리케이션의 보안 테스트를 돕기위한 그래픽 툴 입니다. 다양한 기능을 제공하지만 유료인 Pro 버전이 존재하며 수동으로 테스트 해볼 수 있게 나온 Community 버전이 존대합니다.<br>Pro를 구매할 이유가 없는 관계료 오늘 살펴볼 버전은 Community 버전입니다.<br><code>주의 : Community 버전은 프로젝트를 저장할 수 없습니다. 두고두고 테스트를 진행해야 한다면 좋은 선택이 아닐 수 있습니다.</code></p>
<h3 id="Burp-suite-다운로드-및-설치"><a href="#Burp-suite-다운로드-및-설치" class="headerlink" title="Burp_suite 다운로드 및 설치"></a>Burp_suite 다운로드 및 설치</h3><p>다운로드 경로 : <a href="https://portswigger.net/burp/communitydownload" target="_blank" rel="noopener">https://portswigger.net/burp/communitydownload</a></p>
<img src="/2018/08/18/Burp-suite-%EC%84%A4%EC%B9%98/Burp_Suite_Download.PNG" class="">

<p>java 기반으로 제작된 jar 버전이 있으며, windows 일 경우 exe 버전을 다운로드 받아 install 할 수도 있습니다. 원하는 버전을 다운로드 합니다.<br>글에서는 windows 버전을 기준으로 설치하겠습니다.</p>
<p>다운로드가 완료되었다면 <code>burpsuite_community_windows-x64_v1_7_36.exe</code> 와 유사한 파일이 저장됩니다. 더블클릭 합니다.<br><code>관리자 권한이 필요합니다.</code></p>
<p>windows 버전은 설치가 간단합니다. (사실 java 버전은 설치조차 필요 없을 수도 있겠지만요…)</p>











<p>좋은설치 = 넥스트 고고!</p>
<h3 id="Burp-Suite-실행"><a href="#Burp-Suite-실행" class="headerlink" title="Burp Suite 실행"></a>Burp Suite 실행</h3><p>시작메뉴에 생성된 Burp Shute 를 실행합니다.</p>
<p>잠시간의 로딩 후 아래의 화면을 만나게 됩니다.</p>


<p>프로젝트 정보 등을 저장할 수 없는 임시 프로젝트만 지원한다는 이야기 입니다. 아쉽지만 다음 화면으로 갑시다. <del>Community 버전의 한계</del></p>


<p>첫 실행이므로 별다른 설정이 존재할리 없습니다. default 설정을 선택하고 다음 화면으로 갑니다.</p>


<p>성공적으로 첫 실행화면이 출력되었습니다.</p>
<p>다음 시간에는 Tool 을 이용한 간단한 XSS 테스트를 진행해보겠습니다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Tool/">Tool</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Burp/">Burp</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/09/Selenium을-이용한-Web-Crawler-만들기/"><span>Selenium을 이용한 Web Crawler 만들기</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/09/Selenium을-이용한-Web-Crawler-만들기/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-09T02:15:50.000Z">
          2018-08-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Selenium-이란"><a href="#Selenium-이란" class="headerlink" title="Selenium 이란?"></a>Selenium 이란?</h1><blockquote><p>Selenium automates browsers.</p>
<footer><strong>SeleniumHQ</strong><cite><a href="https://www.seleniumhq.org/" target="_blank" rel="noopener">What is Selenium?</a></cite></footer></blockquote>

<p>Selenium은 <code>webdriver</code>를 통해 웹 브라우저(ie, chrome, firefox 등)를 자동화 하여 웹 에플리케이션을 테스트 할 수 있는 오픈소스 프레임워크입니다.<br>다양한 언어 (c#, java, python) 를 지원하며, 상황에 맞게 골라 사용할 수 있죠.</p>
<p>Selenium에는 <code>Selenium WebDriver</code> 와 <code>Selenium IDE</code> 가 있습니다.</p>
<h2 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium WebDriver"></a>Selenium WebDriver</h2><p><a href="https://www.seleniumhq.org/projects/webdriver/" target="_blank" rel="noopener">Selenium WebDriver</a>는 지금은 사용되지 않는 Selenium Remote Control의 후속제품으로 다음과 같은 기능이 필요할 경우 사용이 추천됩니다.</p>
<ul>
<li><code>브라우저 기반</code>의 강력한 반복 자동화 테스트 생성</li>
<li>여러 환경에서 Script를 확장 및 배포</li>
</ul>
<h2 id="Selenium-IDE"><a href="#Selenium-IDE" class="headerlink" title="Selenium IDE"></a>Selenium IDE</h2><p><a href="https://www.seleniumhq.org/projects/ide/" target="_blank" rel="noopener">Selenium IDE</a>는 Firefox 의 확장프로그램(add-on)으로 간단히 <code>recode</code> 및 <code>playback</code>을 사용할 수 있습니다.<br>다음과 같은 기능이 있을 경우 사용이 추천됩니다.</p>
<ul>
<li>빠른 버그 복제 스크립트 작성</li>
<li>자동화 된 예비 검사를 돕기위한 스크립트 작성</li>
</ul>
<p>이번에 제작하려는 프로그램은 Web Crawler이기 때문에 IDE 는 다음기회에 살펴보기로 하고 Selenium WebDriver를 살펴보기로 합니다.</p>
<hr>
<h1 id="Selenium-python"><a href="#Selenium-python" class="headerlink" title="Selenium + python"></a>Selenium + python</h1><p>Selenium은 많은 언어를 지원하지만 python 을 기반으로 살펴보겠습니다.<br>간단한 프로젝트를 만들때 python 을 사용하는 이유는 다음과 같습니다.</p>
<ul>
<li>비교적 짧은 코드로 얻을 수 있는 만족스러운 결과물</li>
<li>복잡하지 않은 작은 규모의 Application 을 제작하기에 적합</li>
<li>파워풀한 Beautifulsoup</li>
<li>jar 로 배포 시 사용하기 힘들어 하는 사용자가 존재 =&gt; 배포시 간단히 exe 로 변환 가능</li>
</ul>
<h2 id="python-requests-Crawler와의-차이점"><a href="#python-requests-Crawler와의-차이점" class="headerlink" title="python requests Crawler와의 차이점"></a>python requests Crawler와의 차이점</h2><p>사실 이전부터 사용해오던 간단한 Web Crawler가 존재했습니다.<br>python 기반으로 가장 쉽게 제작할 수 있는 Beautifulsoup과 requests를 이용한 Crawler였죠.</p>
<p>기능은 간단했습니다.</p>
<ul>
<li>목표 사이트에 로그인</li>
<li>원하는 커뮤니티로 이동</li>
<li>게시물목록을 읽어들여 게시물 내부의 이미지를 모두 다운로드</li>
</ul>
<p>해당 프로그램은 약 1년 이상 안정적으로, 또한 성공적으로 그 역할을 완수했습니다.</p>
<p>하지만 최근 해당 사이트의 업데이트로 <code>로그인 보안 강화</code>라는 어쩔 수 없는 이유가 발생하게 됩니다.<br><code>requests</code>의 로그인 방식은 id와 password를 해당 사이트에 parameter 로 날려서 로그인 세션을 생성해오게 됩니다.<br>로그인 세션을 발생시키는 url을 확인 후 해당 페이지가 원하는 <code>parameter</code>를 보내주는 방식인거죠.</p>
<p>하지만 이번 업데이트에서는 복잡한 <code>javascript 라이브러리</code>로 사용자의 <code>password</code>와 server 에서 보낸 <code>1회성 key</code>를 조합하여 암호화한 parameter를 넘겨야만 Session이 생성되도록 변경되었습니다.</p>
<p>requests 기반 Crawler의 한계를 느끼는 순간이었습니다.</p>
<h2 id="javascript-function-이용의-필요성"><a href="#javascript-function-이용의-필요성" class="headerlink" title="javascript function 이용의 필요성"></a>javascript function 이용의 필요성</h2><p>사이트 로그인방식은 사실 간단합니다. id 와 pw 를 입력하는 란에 알맞게 넣은 뒤 로그인 버튼을 클릭해주면 되죠. 그 뒤의 복잡한 javascript 구동방식이라던가, 암호화 과정은 고려할 필요가 없습니다.<br><code>Selenium</code> 역시 사용자가 입력하는 것 처럼 적절히 입력하고 클릭이벤트를 발생시켜 줍니다.<br>requests는 문자 형식으로 넘어온 html을 분석하기 때문에 javascript function을 실행시킬 수 없었다면, <code>Selenium</code>은 브라우저 자체를 이용하기 때문에 javascript function 까지도 충분히 이용이 가능합니다.</p>
<p>어라… 뭔가 더 좋은게 아닌가?</p>
<p>다만 속도적인 측면에서는 무조건 requests가 빨랐습니다. 아무래도 브라우저가 해당 페이지를 읽어들이는데 필요한 시간이 존재하기 때문이겠지요.</p>
<hr>
<h2 id="Selenium-설치"><a href="#Selenium-설치" class="headerlink" title="Selenium 설치"></a>Selenium 설치</h2><p>본 포스트는 python 3.5가 이미 설치되어 있는 환경이라고 가정하에 작성됩니다. 많은 호환성이 걱정되신다면 <a href="https://www.anaconda.com/" target="_blank" rel="noopener">Anaconda</a> 환경에서 python 3.5 를 추가하여 사용하시기를 추천드립니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>

<p>설치는 간단히 완료되었습니다. 또한 실제 브라우저가 필요하므로 <a href="https://www.google.com/intl/ko_ALL/chrome/" target="_blank" rel="noopener">chrome</a>이 설치되지 않았다면 빠르게 설치를 진행해줍니다.</p>
<p>다음은 Chrome 기반으로 작성된 Webdriver 인 ChromeDriver 를 다운로드 받아줍시다.</p>
<p>URL : <a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></p>
<p>준비 완료!</p>
<h3 id="라이브라리-import"><a href="#라이브라리-import" class="headerlink" title="라이브라리 import"></a>라이브라리 import</h3><p>우선 필요한 라이브러리들을 import 해줍니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options  </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br></pre></td></tr></table></figure>

<p><code>selenium.webdriver.common.keys</code>는 실제로 사용자가 입력하는 key 이벤트를 발생시키기 위한 라이브러리 입니다.<br>ID와 PW를 입력해 줘야 하니 import 합니다.</p>
<p>다음은 Chrome 구동시 옵션입니다. <code>--headless</code> 를 부여하면 chrome 이 백그라운드에서 동작하며 좀더 속도가 향상됩니다. (headless 모드는 chrome 버전 63 부터 사용 가능합니다.)<br>ChromeDriver를 제작중인 py 파일과 동일한 폴더로 이동시킨 뒤에 해당 Path 를 잡아줍니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chrome_options = Options()  </span><br><span class="line">chrome_options.add_argument(<span class="string">"--headless"</span>)  </span><br><span class="line">chrome_options.binary_location = <span class="string">'C:/Program Files (x86)/Google/Chrome/Application/chrome.exe'</span>  </span><br><span class="line">driver = webdriver.Chrome(executable_path=os.path.abspath(<span class="string">"chromedriver"</span>),   chrome_options=chrome_options)</span><br></pre></td></tr></table></figure>

<p>Chrome을 구동합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://logins.daum.net/accounts/loginform.do"</span>)</span><br></pre></td></tr></table></figure>

<p>해당 페이지가 로드된 뒤 로그인 정보를 입력하고 로그인 버튼을 클릭 합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_id = driver.find_element_by_id(<span class="string">"id"</span>)       <span class="comment">#아이디를 입력할 input 위치</span></span><br><span class="line">my_pw = driver.find_element_by_id(<span class="string">"inputPwd"</span>) <span class="comment">#비밀번호를 입력할 input 위치</span></span><br><span class="line">login_button = driver.find_element_by_id(<span class="string">"loginBtn"</span>) <span class="comment">#로그인버튼</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> login_button.is_displayed():</span><br><span class="line">    my_id.clear()</span><br><span class="line">    my_id.send_keys(<span class="string">"아이디"</span>)</span><br><span class="line">    my_pw.clear()</span><br><span class="line">    my_pw.send_keys(<span class="string">"패스워드"</span>)</span><br><span class="line">    login_button.click()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p><code>my_id.clear()</code>로 혹시나 있을지 모르는 초기값을 제거해준 뒤 <code>my_id.send_keys(&quot;아이디&quot;)</code> 해당 구문을 지정된 input 에 입력해줍니다.</p>
<p>입력이 완료되었다면 <code>login_button.click()</code>으로 로그인을 진행합니다.</p>
<p><code>driver.quit()</code>는 Chrome을 종료시키는 구문입니다. 프로그램이 완료된 뒤 Chrome 이 종료되기를 원한다면 잊어버리면 안됩니다. (특히 <code>headless</code>의 경우 눈에보이지 않기 때문에 자칫하다가 어마어마하게 실행되어버리는 경우가 발생합니다.)</p>
<h1 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며"></a>마무리하며</h1><p>Selenium은 requests보다 러닝커브가 높은편입니다. 또한 다른 사용자를 위해 제작한 프로그램을 exe로 배포하더라도 chrome 과 chromedriver 를 별도로 다운로드 받아야 하는 등의 불편점도 존재합니다.<br>하지만 훨씬 강력하며, 매력적인 프레임워크임에는 틀림없어 보입니다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Python/">Python</a>, <a href="/categories/Python/Selenium/">Selenium</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Python/">Python</a><a href="/tags/Selenium/">Selenium</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/09/Oracle-Row-to-Column-행을-열로-합치기/"><span>[Oracle] Row to Column, 행을 열로 합치기</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/09/Oracle-Row-to-Column-행을-열로-합치기/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-09T01:30:46.000Z">
          2018-08-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>여러 행을 특정 구분자(예:콤마[,])로 구분하며 합쳐야할 경우 사용되는 SQL 이다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SUBSTR</span> (SYS_CONNECT_BY_PATH (PART_NM , <span class="string">','</span>), <span class="number">2</span>)) csv</span><br><span class="line">	<span class="keyword">FROM</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> X.PART_NM , ROW_NUMBER () <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> X.PART_NM ) rn,</span><br><span class="line">		<span class="keyword">COUNT</span> (*) <span class="keyword">OVER</span> () cnt, X.NFIX_REQ_NO</span><br><span class="line">		<span class="keyword">FROM</span> Table_One X</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">WHERE</span> rn = cnt</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> rn = <span class="number">1</span></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> rn = <span class="keyword">PRIOR</span> rn + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>결과 : 콤마로 구분지어져 한줄로 출력된다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Database/">Database</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Oracle/">Oracle</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/08/Equal-Join의-대표적인-3가지/"><span>Equal Join의 대표적인 3가지</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/08/Equal-Join의-대표적인-3가지/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-08T01:24:44.000Z">
          2018-08-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>오라클 기준으로 작성된문서이지만  원리및 장단점을 쉽게 설명했기에 올려봅니다.</p>
<hr>
<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>관계형 데이터 베이스에서 데이터 연결 방법 중 Join의 종류, 조인의 수행원리, 각 조인의 특징, 그리고 조인별 선택기준에 대해서 소개하고자 한다.</p>
<h1 id="Join-정의"><a href="#Join-정의" class="headerlink" title="Join 정의"></a>Join 정의</h1><p>조인은 두 집합간의 곱으로 데이터를 연결하는 가장 대표적인 데이터 연결 방법이다.<br>종류에는 <code>Nested Loop Join</code>, <code>Sort Merge Join</code> 그리고 <code>Hash Join</code>이 있다.<br><code>1 * M = M</code> 과 <code>M * 1 = M</code> 의 결과집합이 동일한 것처럼 Optimizer가 3가지의 조인 중 어떤 것을 선택할지라도 결과집합은 동일하다.</p>
<p>하지만 수행속도 측면에서 본다면 조인하고자 하는 두 집합의 데이터 상황에 따라 어떤 조인을 선택하느냐, 어떤 집합을 먼저 선행하느냐 에 따라 수행속도에 미치는 영향은 크다.</p>
<hr>
<h1 id="수행원리"><a href="#수행원리" class="headerlink" title="수행원리"></a>수행원리</h1><p>100쌍의 남녀가 사랑의 짝대기 하는 것에 비추어 3가지 조인방식이 수행되는 원리를 설명해 보자. </p>
<p>남녀 모두는 자기가 원하는 상대방의 번호표 하나씩 가지고 있고, 한 사람은 여러 사람으로부터 선택 받을 수 있다.</p>
<h2 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested Loop Join"></a>Nested Loop Join</h2><p><code>Nested Loop Join</code>은 선행집합의 처리 범위가 결정되어 지면 후행집합의 일량이 정해지는 종속적 방식이다.</p>
<p>첫번째 여자는 자기가 선택한 번호표를 가지고 처음부터 차례로 남자의 번호를 확인하고, 해당 번호의 남자가 자기를 선택했는지 확인한다.<br>그리고 두 번째, 세 번째…백 번째 여자까지 같은 작업을 반복 수행하게 된다.<br>이처럼 선행 집합의 선두부터 차례로 후행집합과 조건을 비교 하면서 선행집합의 처리범위가 끝날 때 까지 같은 작업을 반복하는 것이 Nested Loop Join이다. </p>
<h3 id="특징-및-사용기준"><a href="#특징-및-사용기준" class="headerlink" title="특징 및 사용기준"></a>특징 및 사용기준</h3><p>온라인 어플리케이션에서 주를 이루는 <code>Nested Loop Join</code>은 부분범위 처리나 사용자가 데이터를 요구 했을 때<br>짧은 시간에 결과를 볼 수 있는 적은 데이터를 액세스 할 때 쓰인다.</p>
<p>다음과 같은 SQL을 예로 들어 보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.FLD1, ..., b.FLD1,...  </span><br><span class="line"><span class="keyword">FROM</span> TAB2 b, TAB1 a</span><br><span class="line"><span class="keyword">WHERE</span> a.KEY1 = b.KEY2 </span><br><span class="line"><span class="keyword">AND</span> b.FLD2 <span class="keyword">like</span> <span class="string">'A%'</span>     </span><br><span class="line"><span class="keyword">AND</span> a.FLD1 = <span class="string">'10'</span></span><br></pre></td></tr></table></figure>

<p>조인 컬럼인 <code>a.KEY1 = b.KEY2</code> 에 양쪽 테이블 모두 인덱스가 존재하고,<br>선행 테이블을 <code>TAB1</code>으로 했을 때와  <code>TAB2</code>로 했을 때의 수행횟수를 비교하여 보자.</p>
<ul>
<li>TAB1이 선행테이블 일때<br>  1 <code>a.FLD1</code> 인덱스 5000건 <code>Range Scan</code>.<br>  2 <code>Rowid</code>로 <code>TAB1</code>에 5000회 랜덤액세스<br>  3 성공/실패에 상관없이 <code>b.KEY2</code> 인덱스에 5000회 랜덤액세스 및 조인시도<br>  4 조인에 성공한 <code>Rowid</code>로 <code>TAB2</code>에 100회 랜덤액세스<br>  5 <code>b.FLD2 like &#39;A%&#39;</code> 체크 후 성공한 50건 운반단위 이동</li>
</ul>
<ul>
<li>TAB2가 선행테이블 일때<br>  1 <code>b.FLD2</code> 인덱스 100건 <code>Range Scan</code>.<br>  2 <code>TAB2</code>의 100회 랜덤액세스<br>  3 성공/실패에 상관없이 <code>a.KEY1</code> 인덱스에 100회 랜덤액세스 및 조인시도<br>  4 조인에 성공한 <code>Rowid</code>로 <code>TAB1</code>에 70회 랜덤액세스<br>  5 <code>a.FLD1 = &#39;10&#39;</code> 체크 후 성공한 50건 운반단위 이동</li>
</ul>
<p>결과건수는 두 가지 수행방식 동일하게 50건이지만, 수행횟수 측면에서 본다면 TAB1을 선행테이블 했을 때는 5000회의 조인시도가 발생하였고,<br>TAB2를 선행테이블로 했을 때는 100회의 조인시도가 발생하였다.<br>이처럼 조인 순서 및 선행 테이블의 처리범위에 따라서 수행횟수는 크게 달라질 수 있다. </p>
<h5 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h5><ul>
<li>선행 테이블의 처리범위가 일량을 결정한다.(방향성)</li>
<li>선행 테이블의 값을 받아서 후행 테이블의 처리범위가 결정된다.(종속적)</li>
<li>주로 랜덤 액세스 방식으로 처리된다.(랜덤액세스)</li>
<li>후행 테이블의 <code>조인컬럼의 인덱스의 유무</code> 및 <code>조건의 인덱스 참여의 정도</code>에 따라 수행속도가 많이 차이 난다.(연결고리 상태)</li>
</ul>
<h5 id="사용기준"><a href="#사용기준" class="headerlink" title="사용기준"></a>사용기준</h5><ul>
<li>부분범위처리를 하는 경우에 유리하다.</li>
<li>처리량이 적은 경우에 유리하다.- 랜덤액세스가 많을 경우 수행속도를 보장할 수 없으므로 <code>Sort Merge Join</code>이나 <code>Hash Join</code>으로 유도</li>
<li>선행 테이블의 결과를 받아야만 후행 테이블의 처리범위를 줄일 수 있는 경우에 유리하다. - <code>연결고리에 Index가 반드시 존재하여야 함</code></li>
<li>선행 테이블의 처리범위가 수행속도에 절대적 영향을 미치므로 <code>최적의 조인 순서가 될 수 있도록 유도</code>해야 한다.</li>
</ul>
<h2 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort Merge Join"></a>Sort Merge Join</h2><p><code>Sort Merge Join</code>은 처리범위를 결정하는데 독립적이다.</p>
<p>남녀는 각각 자기가 선택한 상대방의 번호표(Join Key) 순으로 각각 줄(Sort)을 선다.<br>그러면 중간의 아나운서가 차례로 양쪽의 번호표가 일치하는지를 확인하면서 번호표가 맞다면 짝을 지어줄 것이다.<br>이처럼 각각의 집합은 자기에게 주어진 조건으로 처리범위를 결정하고, 조인 컬럼으로 각각 Sort 한 후 조인하는 방식이 Sort Merge Join이다.</p>
<h3 id="특징-및-사용기준-1"><a href="#특징-및-사용기준-1" class="headerlink" title="특징 및 사용기준"></a>특징 및 사용기준</h3><p>다량의 데이터를 스캔방식으로 처리하는 Sort Merge Join은 양쪽테이블을 각자 액세스하여 처리 범위를 줄이고,<br>조인컬럼 순으로 데이터를 Sort 후에 조인하는 방식이다. </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.FLD1, ..., b.FLD1,...  </span><br><span class="line"><span class="keyword">FROM</span> TAB2 b, TAB1 a</span><br><span class="line"><span class="keyword">WHERE</span> a.KEY1 = b.KEY2 </span><br><span class="line"><span class="keyword">AND</span> b.FLD2 <span class="keyword">like</span> <span class="string">'A%'</span>     </span><br><span class="line"><span class="keyword">AND</span> a.FLD1 = <span class="string">'10'</span></span><br></pre></td></tr></table></figure>

<h4 id="수행-과정"><a href="#수행-과정" class="headerlink" title="수행 과정"></a>수행 과정</h4><p>1 <code>a.FLD1</code> 인덱스 <code>Range Scan</code>.<br>2 <code>Rowid</code>로 <code>TAB1</code>에 랜덤액세스<br>3 조인컬럼인 <code>a.KEY1</code>로 <code>SORT</code><br>4 <code>b.FLD2</code> 인덱스 <code>Range Scan</code>.<br>5 <code>Rowid</code>로 <code>TAB2</code>에 랜덤액세스<br>6 조인컬럼인 <code>b.KEY2</code>로 <code>SORT</code> 한다.<br>7 양쪽 집합을 Scan하면서 <code>a.KEY1 = b.KEY2</code> 조인 시도<br>8 성공한 Row 운반단위 이동</p>
<p>수행과정에서 나타나듯이 Nested Loop Join과 달리 상대 테이블의 결과에 의해 처리범위가 결정되는게 아니라<br>스스로에게 주어진 조건 만으로 처리범위를 줄인 후 Sort하게 되므로, <code>조인 컬럼으로 이루어진 인덱스는 사용하지 않게 된다</code>.</p>
<h5 id="특징-1"><a href="#특징-1" class="headerlink" title="특징"></a>특징</h5><ul>
<li>상대 테이블로부터 결과 값을 제공받지 않고, 자신에게 주어진 조건으로만 처리범위를 결정한다.(<code>독립적</code>).</li>
<li>각자 SORT후에 조인을 하게 되므로 부분범위 처리가 아닌 전체범위 처리를 하게 된다.(<code>전체범위 처리</code>)</li>
<li>조인의 순서에는 상관없다.(<code>무방향성</code>)</li>
<li>인덱스가 아닌 컬럼도 Merge할 작업 대상을 줄이므로 중요한 의미를 가진다.</li>
</ul>
<h5 id="사용기준-1"><a href="#사용기준-1" class="headerlink" title="사용기준"></a>사용기준</h5><ul>
<li><code>처리량이 많거나 전체범위 처리 시에 유리</code>하다. 랜덤액세스가 많은 Nested Loop Join은 불리</li>
<li><code>스스로 자신의 처리범위를 많이 줄일 수 있을 때 유리</code>하다.</li>
<li>연결고리 이상 상태에 영향을 받지 않으므로 연결고리 컬럼을 위한 인덱스를 생성하지 않고도 유용하게 사용할 수 있다.</li>
<li>처리할 데이터량이 적은 온라인 어플리케이션에서는 Nested Loop Join이 유리한 경우가 많으므로 Sort Merge Join은 주의하여 사용한다.</li>
</ul>
<h2 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h2><p><code>Hash Join</code> 역시 처리범위를 결정하는데 독립적이다.</p>
<p>1번부터 100번(Hash Table)의 푯말이 있다.<br>여자측은 자기가 가지고 있는 상대방의 번호표 숫자푯말 앞에 서는 것이다(Hash Function).<br>물론 각 푯말에는 여러 명의 여자가 서 있을 수도, 한명도 없을 수도 있다.<br>다음으로 남자는 자기 번호푯말 앞으로 가서 남자가 가지고 있는 번호와 상대 여성의 번호와 맞는지를 비교하면 된다. </p>
<p>이처럼 선행 집합은 Hash Function을 이용하여 Hash Table을 구성하고,<br>후행집합은 차례로 Hash Function을 이용하여 Hash Table을 탐침하는게 Hash Join 수행 원리다.</p>
<h3 id="특징-및-사용기준-2"><a href="#특징-및-사용기준-2" class="headerlink" title="특징 및 사용기준"></a>특징 및 사용기준</h3><p>대량의 데이터를 액세스하는 작업에서는 시스템 리소스를 많이 사용하는 대신 짧은 시간에 보장할 수 있어야 한다. </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.FLD1, ..., b.FLD1,...  </span><br><span class="line"><span class="keyword">FROM</span> TAB2 b, TAB1 a</span><br><span class="line"><span class="keyword">WHERE</span> a.KEY1 = b.KEY2 </span><br><span class="line"><span class="keyword">AND</span> b.FLD2 <span class="keyword">like</span> <span class="string">'A%'</span>     </span><br><span class="line"><span class="keyword">AND</span> a.FLD1 = <span class="string">'10'</span></span><br></pre></td></tr></table></figure>

<h4 id="수행-과정-1"><a href="#수행-과정-1" class="headerlink" title="수행 과정"></a>수행 과정</h4><p>1 두 테이블 중 <code>적은 테이블을 선행 테이블로 결정</code>한다.<br>2 선행 테이블을 Hash Function을 이용하여 Hash Area에 Hash Table을 구성한다.(Build Input)<br>3 만약 Hash Area만으로 생성 가능하다면 후행테이블은 크기에 상관없이 차례로 Hash Function을 이용하여 Hash Table과 조인(Probe Input)하면서 성공한 결과값을 운반단위로 이동한다.<br>4 만약 Hash Area만으로 Hash Table 생성이 불충분 하다면 Hash Table Overflow가 발생하여 데이터를 나눠서 저장 할 Partition 수를 결정한다.(Fan -out)<br>5 선행 테이블의 조인 컬럼과 Select List 컬럼을 메모리로 읽어 들여 첫번째 해쉬 함수를 이용하여 Partition을 Mapping하고, 두번째 해쉬 함수를 이용하여 해쉬 테이블 생성시 사용 할 해쉬 값을 생성한다.<br>6 선행 테이블의 조인 컬럼의  유일 값만으로 Bit-Vector을 생성한다. (추후 Bit-Vector filtering에 사용하기 위함.)<br>7 Partition에 데이터를 MOVE하고 채워진 Partition은 디스크로 내려간다.<br>8 선행 테이블이 모두 읽혀지면 Partition 테이블을 완성하고, Partition 크기순으로 정렬한 후 작은 Partition N개를 메모리에 로드한다.<br>9 후행 테이블을 읽으면서 조인컬럼으로 Bit-Vector와 Filtering에 성공하였다면, 첫번째 해쉬함수로 Partition을 결정하고, 두번째 해쉬 함수를 이용하여 메모리 상에 있는 선행테이블과 조인하고 성공하면 운반단위로 이동하고, 해당 Partition이 메모리에 존재하지 않는다면 해쉬 키값,조인컬럼, Select List를 디스크에 쓴다.<br>10) 후행 테이블이 모두 읽혀지면, Bit-Vector Filtering에 성공했지만, 조인에 성공하지 못해 미 처리된 선행 파티션과 후행 파티션을 메모리에 올려 차례로 반복수행 한다.</p>
<p>액세스해야 할 데이터가 많을 경우 Sort Merge Join은 Merge 단계에 들어 가기 위해 양쪽 테이블의 처리 범위가 SORT 되어야 하므로 SORT에 대한 부담이 크고,<br>Nested Loop Join은 선행 테이블의 처리 범위가 넓을 경우 그 만큼 랜덤 액세스의 발생으로 수행속도를 보장할 수 없다.<br>이에 반해 Hash Join은 다른 조인에 시스템 리소스를 가장 많이 사용하지만 Hash Function을 이용함으로써 Sort를 하지 않고,<br>각 테이블에 한번만 액세스하여 조인이 이루어 지므로 <code>큰 테이블간이나, 큰 테이블과 적은 테이블의 조인에 효율적인 조인 방법</code>이다.</p>
<h5 id="특징-2"><a href="#특징-2" class="headerlink" title="특징"></a>특징</h5><ul>
<li>다른 테이블의 결과 값을 제공받지 않고, 자신에게 주어진 조건으로만 처리범위를 결정한다.(독립적).</li>
<li>해쉬 함수를 이용 하게 되므로 부분범위 처리를 할 수 없으며 전체범위 처리를 하게 된다.(전체범위 처리)</li>
<li>메모리 영역만으로 해쉬 테이블을 생성시 최적의 효과를 낼 수 있으므로 적은 테이블이 선행으로 온다.</li>
<li>해쉬 함수를 이용하므로 결과값의 정렬을 보장 받을 수 없다.</li>
</ul>
<h5 id="사용기준-2"><a href="#사용기준-2" class="headerlink" title="사용기준"></a>사용기준</h5><ul>
<li>대량의 데이터 액세스 시, 배치 처리, Full Table Scan 하면서 조인 해야 할 때 유리하다.</li>
<li>비용은 많이 들지만 수행속도를 보장해야 하는 작업에 유용하다.(Parallel Query 사용)</li>
<li>가능한 메모리 내에서 작업 가능하도록 init Parameter나 Session 정보를 변경하여 사용한다. (Hash_area_size, Hash_multiblock_io_count 등..)</li>
</ul>
<h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>수행속도는 시스템 리소스와 즉결된다. 사용자는 작업의 성격을 분명히 하고, 작업에 맞는 조인은 선택하여야만 수행 속도를 보장할 수 있다.<br>SQL작성 후 반드시 실행계획를 확인 하여 Optimizer가 사용자가 원하는 액세스를 하는 확인하는 습관을 들어야 한다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Database/">Database</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Oracle/">Oracle</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/" class="pagination-prev">Prev</a>
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 Park-JiHoon
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>