<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Jihoon&#39;s IT Development | Web Developer&#39;s Hobby Development Notes</title>

  
  <meta name="author" content="Park-JiHoon">
  

  
  <meta name="description" content="평소 개발이 취미인 개발자의 마구잡이 정리노트">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Jihoon&#39;s IT Development"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Jihoon&#39;s IT Development" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Jihoon&#39;s IT Development</a>
    </h1>
    <p class="site-description">Web Developer&#39;s Hobby Development Notes</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/29/Jenkins-Blue-Ocean-으로-배포하기/"><span>Jenkins Blue Ocean 으로 배포하기</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/29/Jenkins-Blue-Ocean-으로-배포하기/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-29T00:45:22.000Z">
          2018-08-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Jenkins-란"><a href="#Jenkins-란" class="headerlink" title="Jenkins 란"></a>Jenkins 란</h1><h2 id="중요이슈"><a href="#중요이슈" class="headerlink" title="중요이슈"></a>중요이슈</h2><p>Windows 10 환경에서 Jenkins 로 SSH 를 이용한 배포를 하기 위해서는 SSH KEY가 필요하다.<br>원격지 서버에 ssh pub key 를 잘 등록하고<br>Git Bash 에서도 비밀번호 없이 ssh 가 원활하게 접속되는것을 확인했지만 이상하게도 Jenkins 상의 shell script 에서는 ssh 접속 명령 이후 멈춰버리는 현상이 발생했다.</p>
<ul>
<li>Git Bash 로는 접속 가능</li>
<li>Jenkins Job 에서는 접속 불가<ul>
<li>Blue Ocean 및 일반 Job 에서도 연결되지 않음.</li>
</ul>
</li>
</ul>
<p><del>원인을 파악하기 위해 비슷한 이슈를 구글링해보았지만 나오지 않았다…</del></p>
<h3 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h3><p>ssh 에 -vvv 옵션을 준 뒤 jenkins Job을 실행했다.<br>분명 SSH_Agent 를 사용했으며, SSH 인증 Credential 을 생성하여줬음에도 불구하고 id_rsa 파일을 엉뚱한 곳에서 찾으려고 노력하고 있었다. (털썩)<br>ssh keygen 을 Git Bash 에서 진행했기 때문에 id_rsa 파일은 <code>C:/Users/Park/.ssh</code> 폴더에 들어있었지만 Jenkins 에서 검색중인 폴더는 <code>C:\\WINDOWS\\system32\\config\\systemprofile/.ssh/</code> 였다. <del>이유가 뭐야….</del></p>
<ul>
<li><code>C:/Users/Park/.ssh</code> 내부의 파일을 복사</li>
<li><code>C:\\WINDOWS\\system32\\config\\systemprofile/.ssh/</code>로 이동</li>
</ul>
<p>해결완료.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Tool/">Tool</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Jenkins/">Jenkins</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/23/Intellij-단축키모음/"><span>IntelliJ 단축키모음</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/23/Intellij-단축키모음/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-23T07:23:00.000Z">
          2018-08-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="IntelliJ-단축키-모음"><a href="#IntelliJ-단축키-모음" class="headerlink" title="IntelliJ 단축키 모음"></a>IntelliJ 단축키 모음</h3><p>기본적인 단축키 모음입니다.<br>숙달되면 마우스 의존도가 좀 줄지 않을까 싶은데 맥과 윈도우를 모두 외우려니 여간 힘든게 아니군요… <del>맥을 버리면 편해지려나</del></p>
<p>java 개발자라면 강추 드리는 툴 입니다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Tool/">Tool</a>, <a href="/categories/Tool/IntelliJ/">IntelliJ</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/IntelliJ/">IntelliJ</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/22/git-Unlink-of-file-Failed-Should-I-try-again-문제-해결법/"><span>[Git]Unlink of file Failed. Should I try again? 문제 해결법</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/22/git-Unlink-of-file-Failed-Should-I-try-again-문제-해결법/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-22T04:06:13.000Z">
          2018-08-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="사건개요"><a href="#사건개요" class="headerlink" title="사건개요"></a>사건개요</h3><p>직장 후배가 <code>eclipse</code>의 <code>synchronize git</code>을 사용해 remote Server의 데이터를 <code>pull</code> 해오던 와중에 아무런 메시지 없이 데이터가 가져와지지 않는 현상이 발생했습니다.<br>평소 eclipse를 사용하지 않는 관계로 툴 내부에서 확인이 어려웠고 결국 git bash 를 열었습니다.</p>
<h3 id="git-bash"><a href="#git-bash" class="headerlink" title="git bash"></a>git bash</h3><p>우선 당겨와 보았습니다.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master</span></span><br></pre></td></tr></table></figure>

<p>데이터를 잘 가져오던 중 아래의 메시지와 함께 멈춰버렸습니다.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Unlink of file <span class="string">'파일명'</span> failed. Should I try again? (y/n)</span></span><br></pre></td></tr></table></figure>


<h3 id="해결방안"><a href="#해결방안" class="headerlink" title="해결방안"></a>해결방안</h3><p>해당 문제는 보통 <code>파일</code>을 다른 프로그램이 사용중일 경우에 발생하며, 파일을 잡고있는 다른 응용프로그램을 우선 종료해야합니다.</p>
<blockquote><p>This could mean that another program is using the file, which is preventing git from “moving” the file into or out of the working directory when you are attempting to change branches.</p>
<p>I have had this happen on Windows Vista where eclipse is the program “using” the file. The file may not be actually open in eclipse but may have been opened by a process run by eclipse.</p>
<p>In this event, try closing the file in any applications that might have used it. If that doesn’t work, completely exit any applications which may have opened the file.</p>
<footer><strong>stackoverflow</strong><cite><a href="https://stackoverflow.com/questions/4389833/unlink-of-file-failed-should-i-try-again" target="_blank" rel="noopener">unlink-of-file-failed-should-i-try-again</a></cite></footer></blockquote>

<blockquote><p>이것은 <code>다른 프로그램</code>이 파일을 <code>사용</code>하고 있다는 것을 의미 할 수 있습니다. 이는 git이 브랜치를 변경하려고 할 때 작업 디렉토리 안팎으로 파일을 “이동”하지 못하게합니다.</p>
<p>나는 Windows Vista에서 eclipse가 파일을 “사용”하는 프로그램을 사용하고있다. 파일은 이클립스에서 실제로 열리지 않을 수도 있지만 <code>이클립스에서 실행되는 프로세스</code>에 의해 열렸을 수 있습니다.</p>
<p>이 경우 <code>파일을 사용한 적이있는 응용 프로그램에서 파일을 닫으십시오.</code> 그래도 작동하지 않으면 파일을 열었을 수있는 응용 프로그램을 모두 종료하십시오.</p>
</blockquote>


<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>가장 의심스러웠던 후배 컴퓨터의 <code>eclipse</code>를 종료하였고. 다시 <code>git pull</code> 을 실행하자 <code>diff</code> 창이 정상적으로 떴으며, 문제가 해결되었습니다.<br>이번 문제는 <code>eclipse</code>의 <code>synchronize</code>가 중간에 꼬이면서 발생한 것으로 보입니다. eclipse를 재실행 한 뒤에는 해당 문제가 발생하지 않았습니다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Git/">Git</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/git/">git</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/20/CSRF-이해하기/"><span>CSRF 이해하기</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/20/CSRF-이해하기/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-20T07:44:43.000Z">
          2018-08-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Express 팀의 <a href="https://github.com/pillarjs/csrf" target="_blank" rel="noopener">csrf</a>와<br><a href="https://github.com/expressjs/csurf" target="_blank" rel="noopener">csurf</a> 모듈은 암호화 기능의 사용에 대해 의문을<br>가지는 이슈가 자주 올라옵니다. 이는 CSRF 토큰이 작동하는 방식을 잘못 이해해서 발생하는<br>의문이라고 생각합니다. 어째든, 빠르게 진실을 알아봅시다!</p>
<p>이 문서를 읽고, 질문이 있거나 무언가 잘못된 것이 있다고 생각하면 이슈를 생성하세요!</p>
<h2 id="CSRF-공격은-어떻게-하는거죠"><a href="#CSRF-공격은-어떻게-하는거죠" class="headerlink" title="CSRF 공격은 어떻게 하는거죠?"></a>CSRF 공격은 어떻게 하는거죠?</h2><p>공격자가 자신의 피싱 사이트에 다음과 같은 AJAX 버튼 또는 폼을 만들어 놓고 타겟의<br>사이트로 위조 요청을 보냅니다:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://my.site.com/me/something-destructive"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>여기를 누르면 공짜 돈을 드립니다!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>이것이 문제가 되는 이유는 공격자가 AJAX 등을 통해 <code>DELETE</code> 메서드와 같은 요청을 원본<br>사이트로 문제없이 보낼 수 있기 때문입니다. 만약 원본 사이트에서 세션 데이터나 중요한<br>개인 정보를 다룬다면 아주 중대한 문제입니다. 만약 기술적인 지식이 전무한 사용자가<br>이러한 상황을 만난다면 신용카드 정보 또는 사회 보장 정보를 입력할지도 모릅니다.</p>
<h2 id="CSRF-공격을-어떻게-방어하나요"><a href="#CSRF-공격을-어떻게-방어하나요" class="headerlink" title="CSRF 공격을 어떻게 방어하나요?"></a>CSRF 공격을 어떻게 방어하나요?</h2><h3 id="JSON-API만-사용"><a href="#JSON-API만-사용" class="headerlink" title="JSON API만 사용"></a>JSON API만 사용</h3><p>제한된 CORS 환경에서 JavaScript를 통한 AJAX 호출만 사용합니다. 이 방법은 <code>&lt;form&gt;</code>이<br><code>JSON</code> 같은 정보를 전송할 수 없다는 점을 이용하여 요청 값을 JSON만 허용하는<br>방법입니다. 이 방법은 상기한 형태의 폼을 통한 공격 가능성을 제거합니다.</p>
<h3 id="CORS-비활성화"><a href="#CORS-비활성화" class="headerlink" title="CORS 비활성화"></a>CORS 비활성화</h3><p>CSRF 공격을 배제하는 가장 첫 번째 방법은 cross-origin 요청을 비활성화하는 것입니다.<br>만약 CORS를 허용하려면 사이드 이펙트(부수효과)를 발생시키지 않는 <code>OPTIONS, HEAD, GET</code><br>메서드만 허용시켜야 합니다.</p>
<p>불행히도, 위의 메서드를 통한 요청들은 JavaScript를 사용하지 않으므로 모두 차단되지<br>않습니다. (따라서 CORS를 적용할 수 없습니다)</p>
<h3 id="헤더의-레퍼러-referer-확인"><a href="#헤더의-레퍼러-referer-확인" class="headerlink" title="헤더의 레퍼러(referer) 확인"></a>헤더의 레퍼러(referer) 확인</h3><p>불행히도, 레퍼러 헤더를 확인하는 것은 약간 좋지 않은 문제가 있습니다. 하지만 원본<br>사이트가 아닌 해커의 사이트로부터 들어오는 요청은 언제나 막습니다. 이 방법은 문제가<br>발생할 여지가 없습니다.</p>
<p>예를 들어, 레퍼러 헤더가 자신의 서버가 아닐 땐 세션을 로드할 수 없습니다.</p>
<h3 id="GET-메서드가-사이드-이펙트를-일으키지-않게하기"><a href="#GET-메서드가-사이드-이펙트를-일으키지-않게하기" class="headerlink" title="GET 메서드가 사이드 이펙트를 일으키지 않게하기"></a>GET 메서드가 사이드 이펙트를 일으키지 않게하기</h3><p><code>GET</code> 요청이 데이터베이스의 그 어떤 관련된 데이터도 변경할 수 없게 해야 합니다.<br>이는 주로 초보자들이 많이 하는 실수이며 무려 어플리케이션의 CSRF 공격을 넘어서 수 많은<br>공격을 가능하게 만듭니다.</p>
<h3 id="POST-사용-자제"><a href="#POST-사용-자제" class="headerlink" title="POST 사용 자제"></a>POST 사용 자제</h3><p>왜냐하면 <code>&lt;form&gt;</code>은 <code>GET</code>과 <code>POST</code> 메서드만 허용하기 때문입니다. 이러한 방식 대신<br><code>PUT</code>이나 <code>PATCH</code>, <code>DELETE</code> 같은 메서드를 사용하면 공격자가 사이트를 공격할 수 있는<br>방법이 크게 줄어듭니다.</p>
<h3 id="Method-Override-사용하지-않기"><a href="#Method-Override-사용하지-않기" class="headerlink" title="Method Override 사용하지 않기"></a>Method Override 사용하지 않기</h3><p>많은 어플리케이션들이 기본 폼에 <code>PUT</code> 과 <code>PATCH</code>, <code>DELETE</code> 요청을 지원하기 위해<br><a href="https://github.com/expressjs/method-override" target="_blank" rel="noopener">method-override</a>를 사용합니다.<br>하지만, 이것은, 요청을 완전히 취약점이 없는 취약점으로 변경했습니다.</p>
<p>그러니 어플리케이션에 <code>method-override</code>를 사용하지말고 그냥 AJAX를 쓰는게 낫습니다.</p>
<h3 id="오래된-브라우저는-지원하지-않기"><a href="#오래된-브라우저는-지원하지-않기" class="headerlink" title="오래된 브라우저는 지원하지 않기"></a>오래된 브라우저는 지원하지 않기</h3><p>오래된 브라우저는 CORS와 보안 정책을 지원하지 않습니다. 단순히 오래된 브라우저(주로<br>기술적인 지식이 부족한 컴맹들이 사용하며, 이들은 공격하기 더 쉽습니다)의 지원을 끊는<br>것 만으로도 CSRF 공격 경로를 최소화 할 수 있습니다.</p>
<h3 id="CSRF-토큰"><a href="#CSRF-토큰" class="headerlink" title="CSRF 토큰"></a>CSRF 토큰</h3><p>UNBEKNOWN<br>아아, 마지막 해결법은 바로 CSRF 토큰을 사용하는 것입니다. CSRF 토큰이 어떻게<br>작동하냐구요?</p>
<ol>
<li>서버가 클라이언트로 토큰을 전송합니다.</li>
<li>클라이언트가 폼을 토큰과 함께 제출합니다.</li>
<li>토큰이 올바르지 않으면 서버에서 요청을 거부합니다.</li>
</ol>
<p>공격자는 타겟 사이트에서 CSRF 토큰을 얻는 방법을 찾으려 할 것이고 이 때 JavaScript를<br>쓸 것입니다. 따라서 사이트가 CORS를 지원하지 않는다면 공격자가 CSRF 토큰을 얻을 수<br>있는 방법이 없습니다. 취약점을 제거하세요.</p>
<p><strong>반드시 AJAX를 통해 CSRF 토큰에 접근할 수 없도록 하세요!</strong><br><code>/csrf</code> 같이 바로 토큰을 받아올 수 있는 라우트는 만들지 말고, 특히 그 라우트에 CORS를<br>지원하지 마세요.</p>
<p>토큰은 추측할 수 없어야 하며, 이렇게 하면 공격자가 몇 번의 시도만으로 토큰을 얻기<br>힘들어집니다. 또한, 따로 암호학적인 보안이 필요하지 않습니다. 공격은 서버의 브루트 포스<br>공격이 아닌 사용자가 모르는 사이에 한두 번의 클릭으로 이루어집니다.</p>
<h2 id="BREACH-공격"><a href="#BREACH-공격" class="headerlink" title="BREACH 공격"></a>BREACH 공격</h2><p>여기선 salt를 함께 제공해야 합니다. BREACH 공격은 아주 간단합니다: 만약 서버가<br><code>HTTPS+gzip</code>를 통해 같거나 비슷한 응답을 여러 번 한다면, 공격자는 응답 본문의 컨텐츠를<br>예측할 수 있습니다. (HTTPS를 완전히 쓸모없게 만듭니다) 해결법? 각 응답을 약간씩 다르게<br>만들면 됩니다.</p>
<p>그러므로, CSRF 토큰은 각 요청을 기준으로 매번 다르게 생성됩니다. 하지만 서버는<br>각 요청에 포함된 토큰이 유효한지 확인할 수 있어야 합니다:</p>
<ol>
<li>암호학적으로 안전한 CSRF 토큰은 이제 서버에 의해서만 알려진, (가정) CSRF<br>“비밀”입니다.</li>
<li>이제 CSRF 토큰은 secret과 salt의 해시입니다.</li>
</ol>
<p>추가적인 내용은 다음을 참고하세요:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/BREACH_(security_exploit)" target="_blank" rel="noopener">BREACH</a></li>
<li><a href="http://en.wikipedia.org/wiki/CRIME" target="_blank" rel="noopener">CRIME</a></li>
<li><a href="https://community.qualys.com/blogs/securitylabs/2013/08/07/defending-against-the-breach-attack" target="_blank" rel="noopener">BREACH 공격에 대한 방어</a></li>
<li>[Salt란?][2]</li>
<li><a href="http://d2.naver.com/helloworld/318732" target="_blank" rel="noopener">안전한 패스워드 저장 (한국어)</a></li>
</ul>
<p>참고로 CSRF은 BREACH 공격을 <em>해결</em> 하지 않습니다. 하지만 모듈은 간단히 요청을<br>무작위화 시켜 BREACH 공격을 완화시켜줍니다.</p>
<h2 id="Salt는-안전한-암호화를-할-필요가-없습니다"><a href="#Salt는-안전한-암호화를-할-필요가-없습니다" class="headerlink" title="Salt는 안전한 암호화를 할 필요가 없습니다"></a>Salt는 안전한 암호화를 할 필요가 없습니다</h2><p><strong>왜냐하면 클라이언트는 salt를 알고 있기 때문입니다!!!</strong><br>서버는 <code>&lt;salt&gt;;&lt;token&gt;</code>를 전송할 것이고 클라이언트는 서버로 같은 값을 요청에 포함하여<br>보낼 것 입니다. 그리고 서버는 <code>&lt;secret&gt;+&lt;salt&gt;=&lt;token&gt;</code>이 맞는지 확인할 것입니다.<br>salt는 반드시 토큰과 함께 전송되어야 합니다. 이렇지 않다면 서버는 토큰이 확실한지<br>확인할 수 없습니다.</p>
<p>이것은 간단한 암호학적인 방법입니다.<br>더 많은 방법들이 있지만 더 복잡하며 이 문제에 대해 효과적이지 않습니다.</p>
<h2 id="토큰-생성은-빨라야-합니다"><a href="#토큰-생성은-빨라야-합니다" class="headerlink" title="토큰 생성은 빨라야 합니다!"></a>토큰 생성은 빨라야 합니다!</h2><p><strong>왜냐하면 토큰은 매 요청마다 생성되어야 하기 때문입니다!</strong><br>이 작업은 간단히 <code>Math.random().toString(36).slice(2)</code> 이렇게만 해도 충분하며<br>뿐만 아니라 매우 고성능입니다! 각 요청에 대해 OpenSSL과 같은 암호학적으로 암호화된<br>토큰은 필요하지 않습니다.</p>
<h2 id="secret-데이터-은-비밀일-필요가-없습니다"><a href="#secret-데이터-은-비밀일-필요가-없습니다" class="headerlink" title="secret(데이터)은 비밀일 필요가 없습니다"></a>secret(데이터)은 비밀일 필요가 없습니다</h2><p>하지만 이것은. 데이터베이스를 사용하는 세션 스토어를 쓴다면 클라이언트는 절대 DB에<br>저장된 secret을 읽을 수 없습니다. 하지만 쿠키 세션을 사용한다면 secret은 쿠키에<br>저장되고 클라이언트에게 보내질 것입니다. 그러므로, <strong>쿠키 세션이 <code>httpOnly</code>를<br>사용하도록 하고 클라이언트가 secret을 client-side JavaScript로 읽을 수 없도록 해야<br>합니다!</strong></p>
<h2 id="CSRF-토큰을-잘못-사용하는-경우"><a href="#CSRF-토큰을-잘못-사용하는-경우" class="headerlink" title="CSRF 토큰을 잘못 사용하는 경우"></a>CSRF 토큰을 잘못 사용하는 경우</h2><h3 id="JSON-AJAX-요청에-CSRF-토큰을-사용"><a href="#JSON-AJAX-요청에-CSRF-토큰을-사용" class="headerlink" title="JSON AJAX 요청에 CSRF 토큰을 사용"></a>JSON AJAX 요청에 CSRF 토큰을 사용</h3><p>전술했듯이, 만약 CORS를 지원하지 않고 API가 JSON에 한정되어 있다면, AJAX 요청엔<br>CSRF 토큰을 포함시킬 수 있는 방법이 없습니다.</p>
<h3 id="CSRF-토큰을-AJAX로-전송"><a href="#CSRF-토큰을-AJAX로-전송" class="headerlink" title="CSRF 토큰을 AJAX로 전송"></a>CSRF 토큰을 AJAX로 전송</h3><p>어플리케이션에 <code>GET /csrf</code> 같은 라우트는 절때 만들어선 안되며 CORS를 활성화해서도<br>안됩니다. CSRF 토큰을 API 응답 본문에 포함하여 전송하면 안됩니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>최근 웹은 점점 JSON API를 사용하는 추세이며 브라우저는 더 많은 보안 정책으로 더<br>안전해지고 있기에 CSRF의 중요성은 점점 떨어지고 있습니다. 오래된 브라우저의 사이트<br>접속을 차단하고 많은 사이트 API를 JSON API로 변경하면 근본적으로 CSRF 토큰을 사용할<br>필요가 없어집니다. 그러나 안전을 위해, 언제든 가능할 때, 특히 구현에 사소한 상황이<br>아닐 경우 여전히 이것들을 구현하는 것이 좋습니다.</p>
<p><em>오타나 오역이 있을 수 있습니다. 문제를 발견했다면, 수정해서 PR을 넣어주세요. 많은<br>도움이 됩니다!</em></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/19/Burp-suite-간단사용법/"><span>Burp suite 간단사용법</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/19/Burp-suite-간단사용법/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-19T06:03:14.000Z">
          2018-08-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="프록시-서버-설정"><a href="#프록시-서버-설정" class="headerlink" title="프록시 서버 설정"></a>프록시 서버 설정</h2><h3 id="프록시서버"><a href="#프록시서버" class="headerlink" title="프록시서버"></a>프록시서버</h3><p>서버와 클라이언트 사이에서 중계기 역할을 수행하며 대리로 통신하는 기능을 <code>프록시(Proxy)</code> 라고 합니다. 프록시 서버란 해당 중계기능을 지원하고 있는 서버(컴퓨터) 혹은 응용프로그램 을 말합니다.</p>
<p>Burp Suite 사용을 위해서는 우선 프록시 서버를 설정할 필요가 있습니다.</p>
<p>이번 포스팅에서는 Windows 10 / Chrome 환경에서 프록시 서버를 생성해보겠습니다.</p>
<ul>
<li><p>Chrome의 설정 화면을 열어줍니다.</p>
<ul>
<li><a href="chrome://settings/" target="_blank" rel="noopener">chrome://settings/</a></li>
</ul>
</li>
<li><p>고급 설정 하단의 <code>프록시 설정 열기</code> 를 클릭해줍니다.</p>
</li>
</ul>


<ul>
<li>인터넷 속성에서 LAN 설정을 클릭합니다.</li>
</ul>


<ul>
<li>프록시 서버 란에 체크한 뒤 로컬 서버 ip 인 <code>127.0.0.1</code> 을 넣어주고, Burp Suite 의 기본 포트인 <code>8080</code> 을 설정해줍니다.</li>
</ul>


<ul>
<li>프록시 서버 설정이 완료되었습니다.</li>
</ul>
<h2 id="Burp-Suite-Proxy-확인"><a href="#Burp-Suite-Proxy-확인" class="headerlink" title="Burp Suite Proxy 확인"></a>Burp Suite Proxy 확인</h2><p><em>Burp Suite 프로그램의 설치는 이전 <a href="/2018/08/18/Burp-suite-%EC%84%A4%EC%B9%98/" title="포스트">포스트</a>를 참고해주세요.</em></p>
<ul>
<li>프록시 서버 설정을 완료한 뒤 Burp Suite 프로그램을 실행합니다.</li>
</ul>


<ul>
<li>proxy 탭에서 <code>Intercept is off</code> 를 클릭하여 <code>Intercept is on</code> 으로 변경합니다.</li>
</ul>


<ul>
<li>on 인 동안에는 Chrome 을 통한 브라우징이 모두 Burp Suite 를 통해야만 진행될 수 있게됩니다.</li>
</ul>


<ul>
<li>필요에 따라 On / Off 하면서 사용하면 됩니다.</li>
</ul>
<p><em><code>주의 : Chrome 자체적으로 위험한 Proxy 를 감시하는 기능이 존재합니다. 외부 인터넷 연경 (Google 검색 등)에 제한이 있을 수 있습니다.</code></em></p>
<h2 id="주요-옵션"><a href="#주요-옵션" class="headerlink" title="주요 옵션"></a>주요 옵션</h2><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>패킷을 의도한 대상에 도달 하지 않게 하거나 특정 호스트에 redirect 하거나, 패킷을 삭제할 수도 있습니다.</p>
<h3 id="spider"><a href="#spider" class="headerlink" title="spider"></a>spider</h3><p>spider 기능은 새 링크, 콘텐츠 등을 찾는 데 사용 됩니다. 로그인 폼을 찾으면 자동으로 전송하고, response를 통해 새로운 contents를 찾습니다. 이 정보는 scanner 로 보내져서, 찾아낸 모든 link와 content에 대해 scan을 하게 됩니다.</p>
<h3 id="scanner"><a href="#scanner" class="headerlink" title="scanner"></a>scanner</h3><p>웹 응용 프로그램을 scan하여 취약점을 찾는데 사용 됩니다. 검사의 종류는 passive, active, user-directed가 있습니다. 몇 가지 false positives가 테스트 하는 동안 발생할 수 있습니다. 자동화된 스캐너에는 100% 정확한 결과가 없음을 기억하는 게 중요합니다. 불행하게도 무료 버전으로는 scanner 기능이 제공되지 않습니다.</p>
<h3 id="intruder"><a href="#intruder" class="headerlink" title="intruder"></a>intruder</h3><p>이 기능은 브루트 포스 공격을 수행하거나 웹 응용 프로그램을 fuzzing하거나, 취약점을 exploite하는 것과 같은 다양한 목적을 위해 사용할 수 있습니다.</p>
<h3 id="repeater"><a href="#repeater" class="headerlink" title="repeater"></a>repeater</h3><p>이 기능은 같은 요청을 많은 횟수로 수정해서 보내서, 응답을 분석할 때 사용 됩니다.</p>
<h3 id="sequencer"><a href="#sequencer" class="headerlink" title="sequencer"></a>sequencer</h3><p>이 기능은 주로 웹 응용 프로그램에서 제공 하는 세션 토큰의 임의성을 확인 할 때 사용 됩니다. 이것을 알아내기 위해 다양한 고급 테스트를 수행 합니다.</p>
<h3 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h3><p>이 기능을 사용하여 암호화된 데이터를 다시 원래 형태로 해독하거나, 데이터를 암호화 하기 위하여 사용할 수 있습니다.</p>
<h3 id="comparer"><a href="#comparer" class="headerlink" title="comparer"></a>comparer</h3><p>이 기능은 두 개의 요청, 응답 또는 다른 형태의 데이터 비교를 수행하는 데 사용됩니다. 이 기능은 다른 입력에 대한 응답을 비교 하는 경우에 유용할 수 있습니다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Tool/">Tool</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Burp/">Burp</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/18/Burp-suite-설치/"><span>Burp suite 설치</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/18/Burp-suite-설치/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-18T05:10:10.000Z">
          2018-08-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="Burp-Suite-란"><a href="#Burp-Suite-란" class="headerlink" title="Burp Suite 란"></a>Burp Suite 란</h3><blockquote><p>Burp or Burp Suite is a graphical tool for testing Web application security. The tool is written in Java and developed by PortSwigger Security.</p>
<footer><strong>wikipedia</strong><cite><a href="https://en.wikipedia.org/wiki/Burp_suite" target="_blank" rel="noopener">Burp Suite</a></cite></footer></blockquote>

<p><a href="https://portswigger.net/burp" target="_blank" rel="noopener">Burp Suite</a>는 웹 애플리케이션의 보안 테스트를 돕기위한 그래픽 툴 입니다. 다양한 기능을 제공하지만 유료인 Pro 버전이 존재하며 수동으로 테스트 해볼 수 있게 나온 Community 버전이 존대합니다.<br>Pro를 구매할 이유가 없는 관계료 오늘 살펴볼 버전은 Community 버전입니다.<br><code>주의 : Community 버전은 프로젝트를 저장할 수 없습니다. 두고두고 테스트를 진행해야 한다면 좋은 선택이 아닐 수 있습니다.</code></p>
<h3 id="Burp-suite-다운로드-및-설치"><a href="#Burp-suite-다운로드-및-설치" class="headerlink" title="Burp_suite 다운로드 및 설치"></a>Burp_suite 다운로드 및 설치</h3><p>다운로드 경로 : <a href="https://portswigger.net/burp/communitydownload" target="_blank" rel="noopener">https://portswigger.net/burp/communitydownload</a></p>


<p>java 기반으로 제작된 jar 버전이 있으며, windows 일 경우 exe 버전을 다운로드 받아 install 할 수도 있습니다. 원하는 버전을 다운로드 합니다.<br>글에서는 windows 버전을 기준으로 설치하겠습니다.</p>
<p>다운로드가 완료되었다면 <code>burpsuite_community_windows-x64_v1_7_36.exe</code> 와 유사한 파일이 저장됩니다. 더블클릭 합니다.<br><code>관리자 권한이 필요합니다.</code></p>
<p>windows 버전은 설치가 간단합니다. (사실 java 버전은 설치조차 필요 없을 수도 있겠지만요…)</p>











<p>좋은설치 = 넥스트 고고!</p>
<h3 id="Burp-Suite-실행"><a href="#Burp-Suite-실행" class="headerlink" title="Burp Suite 실행"></a>Burp Suite 실행</h3><p>시작메뉴에 생성된 Burp Shute 를 실행합니다.</p>
<p>잠시간의 로딩 후 아래의 화면을 만나게 됩니다.</p>


<p>프로젝트 정보 등을 저장할 수 없는 임시 프로젝트만 지원한다는 이야기 입니다. 아쉽지만 다음 화면으로 갑시다. <del>Community 버전의 한계</del></p>


<p>첫 실행이므로 별다른 설정이 존재할리 없습니다. default 설정을 선택하고 다음 화면으로 갑니다.</p>


<p>성공적으로 첫 실행화면이 출력되었습니다.</p>
<p>다음 시간에는 Tool 을 이용한 간단한 XSS 테스트를 진행해보겠습니다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Tool/">Tool</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Burp/">Burp</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/09/Selenium을-이용한-Web-Crawler-만들기/"><span>Selenium을 이용한 Web Crawler 만들기</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/09/Selenium을-이용한-Web-Crawler-만들기/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-09T02:15:50.000Z">
          2018-08-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Selenium-이란"><a href="#Selenium-이란" class="headerlink" title="Selenium 이란?"></a>Selenium 이란?</h1><blockquote><p>Selenium automates browsers.</p>
<footer><strong>SeleniumHQ</strong><cite><a href="https://www.seleniumhq.org/" target="_blank" rel="noopener">What is Selenium?</a></cite></footer></blockquote>

<p>Selenium은 <code>webdriver</code>를 통해 웹 브라우저(ie, chrome, firefox 등)를 자동화 하여 웹 에플리케이션을 테스트 할 수 있는 오픈소스 프레임워크입니다.<br>다양한 언어 (c#, java, python) 를 지원하며, 상황에 맞게 골라 사용할 수 있죠.</p>
<p>Selenium에는 <code>Selenium WebDriver</code> 와 <code>Selenium IDE</code> 가 있습니다.</p>
<h2 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium WebDriver"></a>Selenium WebDriver</h2><p><a href="https://www.seleniumhq.org/projects/webdriver/" target="_blank" rel="noopener">Selenium WebDriver</a>는 지금은 사용되지 않는 Selenium Remote Control의 후속제품으로 다음과 같은 기능이 필요할 경우 사용이 추천됩니다.</p>
<ul>
<li><code>브라우저 기반</code>의 강력한 반복 자동화 테스트 생성</li>
<li>여러 환경에서 Script를 확장 및 배포</li>
</ul>
<h2 id="Selenium-IDE"><a href="#Selenium-IDE" class="headerlink" title="Selenium IDE"></a>Selenium IDE</h2><p><a href="https://www.seleniumhq.org/projects/ide/" target="_blank" rel="noopener">Selenium IDE</a>는 Firefox 의 확장프로그램(add-on)으로 간단히 <code>recode</code> 및 <code>playback</code>을 사용할 수 있습니다.<br>다음과 같은 기능이 있을 경우 사용이 추천됩니다.</p>
<ul>
<li>빠른 버그 복제 스크립트 작성</li>
<li>자동화 된 예비 검사를 돕기위한 스크립트 작성</li>
</ul>
<p>이번에 제작하려는 프로그램은 Web Crawler이기 때문에 IDE 는 다음기회에 살펴보기로 하고 Selenium WebDriver를 살펴보기로 합니다.</p>
<hr>
<h1 id="Selenium-python"><a href="#Selenium-python" class="headerlink" title="Selenium + python"></a>Selenium + python</h1><p>Selenium은 많은 언어를 지원하지만 python 을 기반으로 살펴보겠습니다.<br>간단한 프로젝트를 만들때 python 을 사용하는 이유는 다음과 같습니다.</p>
<ul>
<li>비교적 짧은 코드로 얻을 수 있는 만족스러운 결과물</li>
<li>복잡하지 않은 작은 규모의 Application 을 제작하기에 적합</li>
<li>파워풀한 Beautifulsoup</li>
<li>jar 로 배포 시 사용하기 힘들어 하는 사용자가 존재 =&gt; 배포시 간단히 exe 로 변환 가능</li>
</ul>
<h2 id="python-requests-Crawler와의-차이점"><a href="#python-requests-Crawler와의-차이점" class="headerlink" title="python requests Crawler와의 차이점"></a>python requests Crawler와의 차이점</h2><p>사실 이전부터 사용해오던 간단한 Web Crawler가 존재했습니다.<br>python 기반으로 가장 쉽게 제작할 수 있는 Beautifulsoup과 requests를 이용한 Crawler였죠.</p>
<p>기능은 간단했습니다.</p>
<ul>
<li>목표 사이트에 로그인</li>
<li>원하는 커뮤니티로 이동</li>
<li>게시물목록을 읽어들여 게시물 내부의 이미지를 모두 다운로드</li>
</ul>
<p>해당 프로그램은 약 1년 이상 안정적으로, 또한 성공적으로 그 역할을 완수했습니다.</p>
<p>하지만 최근 해당 사이트의 업데이트로 <code>로그인 보안 강화</code>라는 어쩔 수 없는 이유가 발생하게 됩니다.<br><code>requests</code>의 로그인 방식은 id와 password를 해당 사이트에 parameter 로 날려서 로그인 세션을 생성해오게 됩니다.<br>로그인 세션을 발생시키는 url을 확인 후 해당 페이지가 원하는 <code>parameter</code>를 보내주는 방식인거죠.</p>
<p>하지만 이번 업데이트에서는 복잡한 <code>javascript 라이브러리</code>로 사용자의 <code>password</code>와 server 에서 보낸 <code>1회성 key</code>를 조합하여 암호화한 parameter를 넘겨야만 Session이 생성되도록 변경되었습니다.</p>
<p>requests 기반 Crawler의 한계를 느끼는 순간이었습니다.</p>
<h2 id="javascript-function-이용의-필요성"><a href="#javascript-function-이용의-필요성" class="headerlink" title="javascript function 이용의 필요성"></a>javascript function 이용의 필요성</h2><p>사이트 로그인방식은 사실 간단합니다. id 와 pw 를 입력하는 란에 알맞게 넣은 뒤 로그인 버튼을 클릭해주면 되죠. 그 뒤의 복잡한 javascript 구동방식이라던가, 암호화 과정은 고려할 필요가 없습니다.<br><code>Selenium</code> 역시 사용자가 입력하는 것 처럼 적절히 입력하고 클릭이벤트를 발생시켜 줍니다.<br>requests는 문자 형식으로 넘어온 html을 분석하기 때문에 javascript function을 실행시킬 수 없었다면, <code>Selenium</code>은 브라우저 자체를 이용하기 때문에 javascript function 까지도 충분히 이용이 가능합니다.</p>
<p>어라… 뭔가 더 좋은게 아닌가?</p>
<p>다만 속도적인 측면에서는 무조건 requests가 빨랐습니다. 아무래도 브라우저가 해당 페이지를 읽어들이는데 필요한 시간이 존재하기 때문이겠지요.</p>
<hr>
<h2 id="Selenium-설치"><a href="#Selenium-설치" class="headerlink" title="Selenium 설치"></a>Selenium 설치</h2><p>본 포스트는 python 3.5가 이미 설치되어 있는 환경이라고 가정하에 작성됩니다. 많은 호환성이 걱정되신다면 <a href="https://www.anaconda.com/" target="_blank" rel="noopener">Anaconda</a> 환경에서 python 3.5 를 추가하여 사용하시기를 추천드립니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>

<p>설치는 간단히 완료되었습니다. 또한 실제 브라우저가 필요하므로 <a href="https://www.google.com/intl/ko_ALL/chrome/" target="_blank" rel="noopener">chrome</a>이 설치되지 않았다면 빠르게 설치를 진행해줍니다.</p>
<p>다음은 Chrome 기반으로 작성된 Webdriver 인 ChromeDriver 를 다운로드 받아줍시다.</p>
<p>URL : <a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></p>
<p>준비 완료!</p>
<h3 id="라이브라리-import"><a href="#라이브라리-import" class="headerlink" title="라이브라리 import"></a>라이브라리 import</h3><p>우선 필요한 라이브러리들을 import 해줍니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options  </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br></pre></td></tr></table></figure>

<p><code>selenium.webdriver.common.keys</code>는 실제로 사용자가 입력하는 key 이벤트를 발생시키기 위한 라이브러리 입니다.<br>ID와 PW를 입력해 줘야 하니 import 합니다.</p>
<p>다음은 Chrome 구동시 옵션입니다. <code>--headless</code> 를 부여하면 chrome 이 백그라운드에서 동작하며 좀더 속도가 향상됩니다. (headless 모드는 chrome 버전 63 부터 사용 가능합니다.)<br>ChromeDriver를 제작중인 py 파일과 동일한 폴더로 이동시킨 뒤에 해당 Path 를 잡아줍니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chrome_options = Options()  </span><br><span class="line">chrome_options.add_argument(<span class="string">"--headless"</span>)  </span><br><span class="line">chrome_options.binary_location = <span class="string">'C:/Program Files (x86)/Google/Chrome/Application/chrome.exe'</span>  </span><br><span class="line">driver = webdriver.Chrome(executable_path=os.path.abspath(<span class="string">"chromedriver"</span>),   chrome_options=chrome_options)</span><br></pre></td></tr></table></figure>

<p>Chrome을 구동합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"https://logins.daum.net/accounts/loginform.do"</span>)</span><br></pre></td></tr></table></figure>

<p>해당 페이지가 로드된 뒤 로그인 정보를 입력하고 로그인 버튼을 클릭 합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_id = driver.find_element_by_id(<span class="string">"id"</span>)       <span class="comment">#아이디를 입력할 input 위치</span></span><br><span class="line">my_pw = driver.find_element_by_id(<span class="string">"inputPwd"</span>) <span class="comment">#비밀번호를 입력할 input 위치</span></span><br><span class="line">login_button = driver.find_element_by_id(<span class="string">"loginBtn"</span>) <span class="comment">#로그인버튼</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> login_button.is_displayed():</span><br><span class="line">    my_id.clear()</span><br><span class="line">    my_id.send_keys(<span class="string">"아이디"</span>)</span><br><span class="line">    my_pw.clear()</span><br><span class="line">    my_pw.send_keys(<span class="string">"패스워드"</span>)</span><br><span class="line">    login_button.click()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p><code>my_id.clear()</code>로 혹시나 있을지 모르는 초기값을 제거해준 뒤 <code>my_id.send_keys(&quot;아이디&quot;)</code> 해당 구문을 지정된 input 에 입력해줍니다.</p>
<p>입력이 완료되었다면 <code>login_button.click()</code>으로 로그인을 진행합니다.</p>
<p><code>driver.quit()</code>는 Chrome을 종료시키는 구문입니다. 프로그램이 완료된 뒤 Chrome 이 종료되기를 원한다면 잊어버리면 안됩니다. (특히 <code>headless</code>의 경우 눈에보이지 않기 때문에 자칫하다가 어마어마하게 실행되어버리는 경우가 발생합니다.)</p>
<h1 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며"></a>마무리하며</h1><p>Selenium은 requests보다 러닝커브가 높은편입니다. 또한 다른 사용자를 위해 제작한 프로그램을 exe로 배포하더라도 chrome 과 chromedriver 를 별도로 다운로드 받아야 하는 등의 불편점도 존재합니다.<br>하지만 훨씬 강력하며, 매력적인 프레임워크임에는 틀림없어 보입니다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Python/">Python</a>, <a href="/categories/Python/Selenium/">Selenium</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Python/">Python</a><a href="/tags/Selenium/">Selenium</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/09/Oracle-Row-to-Column-행을-열로-합치기/"><span>[Oracle] Row to Column, 행을 열로 합치기</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/09/Oracle-Row-to-Column-행을-열로-합치기/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-09T01:30:46.000Z">
          2018-08-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>여러 행을 특정 구분자(예:콤마[,])로 구분하며 합쳐야할 경우 사용되는 SQL 이다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SUBSTR</span> (SYS_CONNECT_BY_PATH (PART_NM , <span class="string">','</span>), <span class="number">2</span>)) csv</span><br><span class="line">	<span class="keyword">FROM</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> X.PART_NM , ROW_NUMBER () <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> X.PART_NM ) rn,</span><br><span class="line">		<span class="keyword">COUNT</span> (*) <span class="keyword">OVER</span> () cnt, X.NFIX_REQ_NO</span><br><span class="line">		<span class="keyword">FROM</span> Table_One X</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">WHERE</span> rn = cnt</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> rn = <span class="number">1</span></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> rn = <span class="keyword">PRIOR</span> rn + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>결과 : 콤마로 구분지어져 한줄로 출력된다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Database/">Database</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Oracle/">Oracle</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/08/Equal-Join의-대표적인-3가지/"><span>Equal Join의 대표적인 3가지</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/08/Equal-Join의-대표적인-3가지/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-08T01:24:44.000Z">
          2018-08-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>오라클 기준으로 작성된문서이지만  원리및 장단점을 쉽게 설명했기에 올려봅니다.</p>
<hr>
<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>관계형 데이터 베이스에서 데이터 연결 방법 중 Join의 종류, 조인의 수행원리, 각 조인의 특징, 그리고 조인별 선택기준에 대해서 소개하고자 한다.</p>
<h1 id="Join-정의"><a href="#Join-정의" class="headerlink" title="Join 정의"></a>Join 정의</h1><p>조인은 두 집합간의 곱으로 데이터를 연결하는 가장 대표적인 데이터 연결 방법이다.<br>종류에는 <code>Nested Loop Join</code>, <code>Sort Merge Join</code> 그리고 <code>Hash Join</code>이 있다.<br><code>1 * M = M</code> 과 <code>M * 1 = M</code> 의 결과집합이 동일한 것처럼 Optimizer가 3가지의 조인 중 어떤 것을 선택할지라도 결과집합은 동일하다.</p>
<p>하지만 수행속도 측면에서 본다면 조인하고자 하는 두 집합의 데이터 상황에 따라 어떤 조인을 선택하느냐, 어떤 집합을 먼저 선행하느냐 에 따라 수행속도에 미치는 영향은 크다.</p>
<hr>
<h1 id="수행원리"><a href="#수행원리" class="headerlink" title="수행원리"></a>수행원리</h1><p>100쌍의 남녀가 사랑의 짝대기 하는 것에 비추어 3가지 조인방식이 수행되는 원리를 설명해 보자. </p>
<p>남녀 모두는 자기가 원하는 상대방의 번호표 하나씩 가지고 있고, 한 사람은 여러 사람으로부터 선택 받을 수 있다.</p>
<h2 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested Loop Join"></a>Nested Loop Join</h2><p><code>Nested Loop Join</code>은 선행집합의 처리 범위가 결정되어 지면 후행집합의 일량이 정해지는 종속적 방식이다.</p>
<p>첫번째 여자는 자기가 선택한 번호표를 가지고 처음부터 차례로 남자의 번호를 확인하고, 해당 번호의 남자가 자기를 선택했는지 확인한다.<br>그리고 두 번째, 세 번째…백 번째 여자까지 같은 작업을 반복 수행하게 된다.<br>이처럼 선행 집합의 선두부터 차례로 후행집합과 조건을 비교 하면서 선행집합의 처리범위가 끝날 때 까지 같은 작업을 반복하는 것이 Nested Loop Join이다. </p>
<h3 id="특징-및-사용기준"><a href="#특징-및-사용기준" class="headerlink" title="특징 및 사용기준"></a>특징 및 사용기준</h3><p>온라인 어플리케이션에서 주를 이루는 <code>Nested Loop Join</code>은 부분범위 처리나 사용자가 데이터를 요구 했을 때<br>짧은 시간에 결과를 볼 수 있는 적은 데이터를 액세스 할 때 쓰인다.</p>
<p>다음과 같은 SQL을 예로 들어 보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.FLD1, ..., b.FLD1,...  </span><br><span class="line"><span class="keyword">FROM</span> TAB2 b, TAB1 a</span><br><span class="line"><span class="keyword">WHERE</span> a.KEY1 = b.KEY2 </span><br><span class="line"><span class="keyword">AND</span> b.FLD2 <span class="keyword">like</span> <span class="string">'A%'</span>     </span><br><span class="line"><span class="keyword">AND</span> a.FLD1 = <span class="string">'10'</span></span><br></pre></td></tr></table></figure>

<p>조인 컬럼인 <code>a.KEY1 = b.KEY2</code> 에 양쪽 테이블 모두 인덱스가 존재하고,<br>선행 테이블을 <code>TAB1</code>으로 했을 때와  <code>TAB2</code>로 했을 때의 수행횟수를 비교하여 보자.</p>
<ul>
<li>TAB1이 선행테이블 일때<br>  1 <code>a.FLD1</code> 인덱스 5000건 <code>Range Scan</code>.<br>  2 <code>Rowid</code>로 <code>TAB1</code>에 5000회 랜덤액세스<br>  3 성공/실패에 상관없이 <code>b.KEY2</code> 인덱스에 5000회 랜덤액세스 및 조인시도<br>  4 조인에 성공한 <code>Rowid</code>로 <code>TAB2</code>에 100회 랜덤액세스<br>  5 <code>b.FLD2 like &#39;A%&#39;</code> 체크 후 성공한 50건 운반단위 이동</li>
</ul>
<ul>
<li>TAB2가 선행테이블 일때<br>  1 <code>b.FLD2</code> 인덱스 100건 <code>Range Scan</code>.<br>  2 <code>TAB2</code>의 100회 랜덤액세스<br>  3 성공/실패에 상관없이 <code>a.KEY1</code> 인덱스에 100회 랜덤액세스 및 조인시도<br>  4 조인에 성공한 <code>Rowid</code>로 <code>TAB1</code>에 70회 랜덤액세스<br>  5 <code>a.FLD1 = &#39;10&#39;</code> 체크 후 성공한 50건 운반단위 이동</li>
</ul>
<p>결과건수는 두 가지 수행방식 동일하게 50건이지만, 수행횟수 측면에서 본다면 TAB1을 선행테이블 했을 때는 5000회의 조인시도가 발생하였고,<br>TAB2를 선행테이블로 했을 때는 100회의 조인시도가 발생하였다.<br>이처럼 조인 순서 및 선행 테이블의 처리범위에 따라서 수행횟수는 크게 달라질 수 있다. </p>
<h5 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h5><ul>
<li>선행 테이블의 처리범위가 일량을 결정한다.(방향성)</li>
<li>선행 테이블의 값을 받아서 후행 테이블의 처리범위가 결정된다.(종속적)</li>
<li>주로 랜덤 액세스 방식으로 처리된다.(랜덤액세스)</li>
<li>후행 테이블의 <code>조인컬럼의 인덱스의 유무</code> 및 <code>조건의 인덱스 참여의 정도</code>에 따라 수행속도가 많이 차이 난다.(연결고리 상태)</li>
</ul>
<h5 id="사용기준"><a href="#사용기준" class="headerlink" title="사용기준"></a>사용기준</h5><ul>
<li>부분범위처리를 하는 경우에 유리하다.</li>
<li>처리량이 적은 경우에 유리하다.- 랜덤액세스가 많을 경우 수행속도를 보장할 수 없으므로 <code>Sort Merge Join</code>이나 <code>Hash Join</code>으로 유도</li>
<li>선행 테이블의 결과를 받아야만 후행 테이블의 처리범위를 줄일 수 있는 경우에 유리하다. - <code>연결고리에 Index가 반드시 존재하여야 함</code></li>
<li>선행 테이블의 처리범위가 수행속도에 절대적 영향을 미치므로 <code>최적의 조인 순서가 될 수 있도록 유도</code>해야 한다.</li>
</ul>
<h2 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort Merge Join"></a>Sort Merge Join</h2><p><code>Sort Merge Join</code>은 처리범위를 결정하는데 독립적이다.</p>
<p>남녀는 각각 자기가 선택한 상대방의 번호표(Join Key) 순으로 각각 줄(Sort)을 선다.<br>그러면 중간의 아나운서가 차례로 양쪽의 번호표가 일치하는지를 확인하면서 번호표가 맞다면 짝을 지어줄 것이다.<br>이처럼 각각의 집합은 자기에게 주어진 조건으로 처리범위를 결정하고, 조인 컬럼으로 각각 Sort 한 후 조인하는 방식이 Sort Merge Join이다.</p>
<h3 id="특징-및-사용기준-1"><a href="#특징-및-사용기준-1" class="headerlink" title="특징 및 사용기준"></a>특징 및 사용기준</h3><p>다량의 데이터를 스캔방식으로 처리하는 Sort Merge Join은 양쪽테이블을 각자 액세스하여 처리 범위를 줄이고,<br>조인컬럼 순으로 데이터를 Sort 후에 조인하는 방식이다. </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.FLD1, ..., b.FLD1,...  </span><br><span class="line"><span class="keyword">FROM</span> TAB2 b, TAB1 a</span><br><span class="line"><span class="keyword">WHERE</span> a.KEY1 = b.KEY2 </span><br><span class="line"><span class="keyword">AND</span> b.FLD2 <span class="keyword">like</span> <span class="string">'A%'</span>     </span><br><span class="line"><span class="keyword">AND</span> a.FLD1 = <span class="string">'10'</span></span><br></pre></td></tr></table></figure>

<h4 id="수행-과정"><a href="#수행-과정" class="headerlink" title="수행 과정"></a>수행 과정</h4><p>1 <code>a.FLD1</code> 인덱스 <code>Range Scan</code>.<br>2 <code>Rowid</code>로 <code>TAB1</code>에 랜덤액세스<br>3 조인컬럼인 <code>a.KEY1</code>로 <code>SORT</code><br>4 <code>b.FLD2</code> 인덱스 <code>Range Scan</code>.<br>5 <code>Rowid</code>로 <code>TAB2</code>에 랜덤액세스<br>6 조인컬럼인 <code>b.KEY2</code>로 <code>SORT</code> 한다.<br>7 양쪽 집합을 Scan하면서 <code>a.KEY1 = b.KEY2</code> 조인 시도<br>8 성공한 Row 운반단위 이동</p>
<p>수행과정에서 나타나듯이 Nested Loop Join과 달리 상대 테이블의 결과에 의해 처리범위가 결정되는게 아니라<br>스스로에게 주어진 조건 만으로 처리범위를 줄인 후 Sort하게 되므로, <code>조인 컬럼으로 이루어진 인덱스는 사용하지 않게 된다</code>.</p>
<h5 id="특징-1"><a href="#특징-1" class="headerlink" title="특징"></a>특징</h5><ul>
<li>상대 테이블로부터 결과 값을 제공받지 않고, 자신에게 주어진 조건으로만 처리범위를 결정한다.(<code>독립적</code>).</li>
<li>각자 SORT후에 조인을 하게 되므로 부분범위 처리가 아닌 전체범위 처리를 하게 된다.(<code>전체범위 처리</code>)</li>
<li>조인의 순서에는 상관없다.(<code>무방향성</code>)</li>
<li>인덱스가 아닌 컬럼도 Merge할 작업 대상을 줄이므로 중요한 의미를 가진다.</li>
</ul>
<h5 id="사용기준-1"><a href="#사용기준-1" class="headerlink" title="사용기준"></a>사용기준</h5><ul>
<li><code>처리량이 많거나 전체범위 처리 시에 유리</code>하다. 랜덤액세스가 많은 Nested Loop Join은 불리</li>
<li><code>스스로 자신의 처리범위를 많이 줄일 수 있을 때 유리</code>하다.</li>
<li>연결고리 이상 상태에 영향을 받지 않으므로 연결고리 컬럼을 위한 인덱스를 생성하지 않고도 유용하게 사용할 수 있다.</li>
<li>처리할 데이터량이 적은 온라인 어플리케이션에서는 Nested Loop Join이 유리한 경우가 많으므로 Sort Merge Join은 주의하여 사용한다.</li>
</ul>
<h2 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h2><p><code>Hash Join</code> 역시 처리범위를 결정하는데 독립적이다.</p>
<p>1번부터 100번(Hash Table)의 푯말이 있다.<br>여자측은 자기가 가지고 있는 상대방의 번호표 숫자푯말 앞에 서는 것이다(Hash Function).<br>물론 각 푯말에는 여러 명의 여자가 서 있을 수도, 한명도 없을 수도 있다.<br>다음으로 남자는 자기 번호푯말 앞으로 가서 남자가 가지고 있는 번호와 상대 여성의 번호와 맞는지를 비교하면 된다. </p>
<p>이처럼 선행 집합은 Hash Function을 이용하여 Hash Table을 구성하고,<br>후행집합은 차례로 Hash Function을 이용하여 Hash Table을 탐침하는게 Hash Join 수행 원리다.</p>
<h3 id="특징-및-사용기준-2"><a href="#특징-및-사용기준-2" class="headerlink" title="특징 및 사용기준"></a>특징 및 사용기준</h3><p>대량의 데이터를 액세스하는 작업에서는 시스템 리소스를 많이 사용하는 대신 짧은 시간에 보장할 수 있어야 한다. </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.FLD1, ..., b.FLD1,...  </span><br><span class="line"><span class="keyword">FROM</span> TAB2 b, TAB1 a</span><br><span class="line"><span class="keyword">WHERE</span> a.KEY1 = b.KEY2 </span><br><span class="line"><span class="keyword">AND</span> b.FLD2 <span class="keyword">like</span> <span class="string">'A%'</span>     </span><br><span class="line"><span class="keyword">AND</span> a.FLD1 = <span class="string">'10'</span></span><br></pre></td></tr></table></figure>

<h4 id="수행-과정-1"><a href="#수행-과정-1" class="headerlink" title="수행 과정"></a>수행 과정</h4><p>1 두 테이블 중 <code>적은 테이블을 선행 테이블로 결정</code>한다.<br>2 선행 테이블을 Hash Function을 이용하여 Hash Area에 Hash Table을 구성한다.(Build Input)<br>3 만약 Hash Area만으로 생성 가능하다면 후행테이블은 크기에 상관없이 차례로 Hash Function을 이용하여 Hash Table과 조인(Probe Input)하면서 성공한 결과값을 운반단위로 이동한다.<br>4 만약 Hash Area만으로 Hash Table 생성이 불충분 하다면 Hash Table Overflow가 발생하여 데이터를 나눠서 저장 할 Partition 수를 결정한다.(Fan -out)<br>5 선행 테이블의 조인 컬럼과 Select List 컬럼을 메모리로 읽어 들여 첫번째 해쉬 함수를 이용하여 Partition을 Mapping하고, 두번째 해쉬 함수를 이용하여 해쉬 테이블 생성시 사용 할 해쉬 값을 생성한다.<br>6 선행 테이블의 조인 컬럼의  유일 값만으로 Bit-Vector을 생성한다. (추후 Bit-Vector filtering에 사용하기 위함.)<br>7 Partition에 데이터를 MOVE하고 채워진 Partition은 디스크로 내려간다.<br>8 선행 테이블이 모두 읽혀지면 Partition 테이블을 완성하고, Partition 크기순으로 정렬한 후 작은 Partition N개를 메모리에 로드한다.<br>9 후행 테이블을 읽으면서 조인컬럼으로 Bit-Vector와 Filtering에 성공하였다면, 첫번째 해쉬함수로 Partition을 결정하고, 두번째 해쉬 함수를 이용하여 메모리 상에 있는 선행테이블과 조인하고 성공하면 운반단위로 이동하고, 해당 Partition이 메모리에 존재하지 않는다면 해쉬 키값,조인컬럼, Select List를 디스크에 쓴다.<br>10) 후행 테이블이 모두 읽혀지면, Bit-Vector Filtering에 성공했지만, 조인에 성공하지 못해 미 처리된 선행 파티션과 후행 파티션을 메모리에 올려 차례로 반복수행 한다.</p>
<p>액세스해야 할 데이터가 많을 경우 Sort Merge Join은 Merge 단계에 들어 가기 위해 양쪽 테이블의 처리 범위가 SORT 되어야 하므로 SORT에 대한 부담이 크고,<br>Nested Loop Join은 선행 테이블의 처리 범위가 넓을 경우 그 만큼 랜덤 액세스의 발생으로 수행속도를 보장할 수 없다.<br>이에 반해 Hash Join은 다른 조인에 시스템 리소스를 가장 많이 사용하지만 Hash Function을 이용함으로써 Sort를 하지 않고,<br>각 테이블에 한번만 액세스하여 조인이 이루어 지므로 <code>큰 테이블간이나, 큰 테이블과 적은 테이블의 조인에 효율적인 조인 방법</code>이다.</p>
<h5 id="특징-2"><a href="#특징-2" class="headerlink" title="특징"></a>특징</h5><ul>
<li>다른 테이블의 결과 값을 제공받지 않고, 자신에게 주어진 조건으로만 처리범위를 결정한다.(독립적).</li>
<li>해쉬 함수를 이용 하게 되므로 부분범위 처리를 할 수 없으며 전체범위 처리를 하게 된다.(전체범위 처리)</li>
<li>메모리 영역만으로 해쉬 테이블을 생성시 최적의 효과를 낼 수 있으므로 적은 테이블이 선행으로 온다.</li>
<li>해쉬 함수를 이용하므로 결과값의 정렬을 보장 받을 수 없다.</li>
</ul>
<h5 id="사용기준-2"><a href="#사용기준-2" class="headerlink" title="사용기준"></a>사용기준</h5><ul>
<li>대량의 데이터 액세스 시, 배치 처리, Full Table Scan 하면서 조인 해야 할 때 유리하다.</li>
<li>비용은 많이 들지만 수행속도를 보장해야 하는 작업에 유용하다.(Parallel Query 사용)</li>
<li>가능한 메모리 내에서 작업 가능하도록 init Parameter나 Session 정보를 변경하여 사용한다. (Hash_area_size, Hash_multiblock_io_count 등..)</li>
</ul>
<h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>수행속도는 시스템 리소스와 즉결된다. 사용자는 작업의 성격을 분명히 하고, 작업에 맞는 조인은 선택하여야만 수행 속도를 보장할 수 있다.<br>SQL작성 후 반드시 실행계획를 확인 하여 Optimizer가 사용자가 원하는 액세스를 하는 확인하는 습관을 들어야 한다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Database/">Database</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Oracle/">Oracle</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 Park-JiHoon
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>